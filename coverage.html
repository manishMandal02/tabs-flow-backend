
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>lambda_authorizer: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/manishMandal02/tabsflow-backend/cmd/auth/lambda_authorizer/main.go (0.0%)</option>
				
				<option value="file1">github.com/manishMandal02/tabsflow-backend/cmd/auth/main.go (0.0%)</option>
				
				<option value="file2">github.com/manishMandal02/tabsflow-backend/cmd/email/main.go (0.0%)</option>
				
				<option value="file3">github.com/manishMandal02/tabsflow-backend/cmd/local_server/main.go (0.0%)</option>
				
				<option value="file4">github.com/manishMandal02/tabsflow-backend/cmd/notes/main.go (0.0%)</option>
				
				<option value="file5">github.com/manishMandal02/tabsflow-backend/cmd/notifications/main.go (0.0%)</option>
				
				<option value="file6">github.com/manishMandal02/tabsflow-backend/cmd/spaces/main.go (0.0%)</option>
				
				<option value="file7">github.com/manishMandal02/tabsflow-backend/cmd/users/main.go (0.0%)</option>
				
				<option value="file8">github.com/manishMandal02/tabsflow-backend/config/config.go (0.0%)</option>
				
				<option value="file9">github.com/manishMandal02/tabsflow-backend/internal/auth/handlers.go (0.0%)</option>
				
				<option value="file10">github.com/manishMandal02/tabsflow-backend/internal/auth/helpers.go (0.0%)</option>
				
				<option value="file11">github.com/manishMandal02/tabsflow-backend/internal/auth/repository.go (0.0%)</option>
				
				<option value="file12">github.com/manishMandal02/tabsflow-backend/internal/auth/routes.go (0.0%)</option>
				
				<option value="file13">github.com/manishMandal02/tabsflow-backend/internal/email/email.go (0.0%)</option>
				
				<option value="file14">github.com/manishMandal02/tabsflow-backend/internal/email/zepto_mail.go (0.0%)</option>
				
				<option value="file15">github.com/manishMandal02/tabsflow-backend/internal/notes/handlers.go (0.0%)</option>
				
				<option value="file16">github.com/manishMandal02/tabsflow-backend/internal/notes/notes.go (0.0%)</option>
				
				<option value="file17">github.com/manishMandal02/tabsflow-backend/internal/notes/reposiotry.go (0.0%)</option>
				
				<option value="file18">github.com/manishMandal02/tabsflow-backend/internal/notes/routes.go (0.0%)</option>
				
				<option value="file19">github.com/manishMandal02/tabsflow-backend/internal/notifications/api_handlers.go (0.0%)</option>
				
				<option value="file20">github.com/manishMandal02/tabsflow-backend/internal/notifications/events_handler.go (0.0%)</option>
				
				<option value="file21">github.com/manishMandal02/tabsflow-backend/internal/notifications/notifications.go (0.0%)</option>
				
				<option value="file22">github.com/manishMandal02/tabsflow-backend/internal/notifications/repository.go (0.0%)</option>
				
				<option value="file23">github.com/manishMandal02/tabsflow-backend/internal/notifications/routes.go (0.0%)</option>
				
				<option value="file24">github.com/manishMandal02/tabsflow-backend/internal/spaces/handlers.go (0.0%)</option>
				
				<option value="file25">github.com/manishMandal02/tabsflow-backend/internal/spaces/repository.go (0.0%)</option>
				
				<option value="file26">github.com/manishMandal02/tabsflow-backend/internal/spaces/routes.go (0.0%)</option>
				
				<option value="file27">github.com/manishMandal02/tabsflow-backend/internal/spaces/spaces.go (0.0%)</option>
				
				<option value="file28">github.com/manishMandal02/tabsflow-backend/internal/users/handlers.go (22.6%)</option>
				
				<option value="file29">github.com/manishMandal02/tabsflow-backend/internal/users/helpers.go (42.9%)</option>
				
				<option value="file30">github.com/manishMandal02/tabsflow-backend/internal/users/repository.go (20.1%)</option>
				
				<option value="file31">github.com/manishMandal02/tabsflow-backend/internal/users/routes.go (100.0%)</option>
				
				<option value="file32">github.com/manishMandal02/tabsflow-backend/internal/users/users.go (100.0%)</option>
				
				<option value="file33">github.com/manishMandal02/tabsflow-backend/pkg/db/db.go (14.3%)</option>
				
				<option value="file34">github.com/manishMandal02/tabsflow-backend/pkg/db/helpers.go (0.0%)</option>
				
				<option value="file35">github.com/manishMandal02/tabsflow-backend/pkg/events/events.go (76.9%)</option>
				
				<option value="file36">github.com/manishMandal02/tabsflow-backend/pkg/events/queue.go (35.7%)</option>
				
				<option value="file37">github.com/manishMandal02/tabsflow-backend/pkg/events/scheduler.go (0.0%)</option>
				
				<option value="file38">github.com/manishMandal02/tabsflow-backend/pkg/http_api/api_gateway_handler.go (0.0%)</option>
				
				<option value="file39">github.com/manishMandal02/tabsflow-backend/pkg/http_api/client.go (0.0%)</option>
				
				<option value="file40">github.com/manishMandal02/tabsflow-backend/pkg/http_api/http_api.go (17.4%)</option>
				
				<option value="file41">github.com/manishMandal02/tabsflow-backend/pkg/http_api/router.go (69.2%)</option>
				
				<option value="file42">github.com/manishMandal02/tabsflow-backend/pkg/logger/logger.go (100.0%)</option>
				
				<option value="file43">github.com/manishMandal02/tabsflow-backend/pkg/test_utils/assertions.go (0.0%)</option>
				
				<option value="file44">github.com/manishMandal02/tabsflow-backend/pkg/test_utils/ddb_mock.go (27.6%)</option>
				
				<option value="file45">github.com/manishMandal02/tabsflow-backend/pkg/test_utils/http_client.go (0.0%)</option>
				
				<option value="file46">github.com/manishMandal02/tabsflow-backend/pkg/test_utils/http_utils.go (0.0%)</option>
				
				<option value="file47">github.com/manishMandal02/tabsflow-backend/pkg/test_utils/sqs_queue_mock.go (55.6%)</option>
				
				<option value="file48">github.com/manishMandal02/tabsflow-backend/pkg/utils/utils.go (43.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "github.com/aws/aws-lambda-go/lambda"
        "github.com/manishMandal02/tabsflow-backend/config"
        "github.com/manishMandal02/tabsflow-backend/internal/auth"
)

func main() <span class="cov0" title="0">{
        // Initialize
        config.Init()

        lambda.Start(auth.LambdaAuthorizer)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "github.com/aws/aws-lambda-go/lambda"
        "github.com/manishMandal02/tabsflow-backend/config"
        "github.com/manishMandal02/tabsflow-backend/internal/auth"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
)

func main() <span class="cov0" title="0">{

        // load config
        config.Init()

        handler := http_api.NewAPIGatewayHandler("/auth/", auth.Router())

        lambda.Start(handler.Handle)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "github.com/aws/aws-lambda-go/lambda"
        "github.com/manishMandal02/tabsflow-backend/config"
        "github.com/manishMandal02/tabsflow-backend/internal/email"
)

func main() <span class="cov0" title="0">{

        // load config
        config.Init()

        lambda.Start(email.SendEmail)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "net/http"
        "time"

        "github.com/manishMandal02/tabsflow-backend/config"
        "github.com/manishMandal02/tabsflow-backend/internal/auth"
        "github.com/manishMandal02/tabsflow-backend/internal/notes"
        "github.com/manishMandal02/tabsflow-backend/internal/notifications"
        "github.com/manishMandal02/tabsflow-backend/internal/spaces"
        "github.com/manishMandal02/tabsflow-backend/internal/users"
        "github.com/manishMandal02/tabsflow-backend/pkg/db"
        "github.com/manishMandal02/tabsflow-backend/pkg/events"
)

// lambda authorizer simple moc
func authorizer(next http.Handler) http.Handler <span class="cov0" title="0">{

        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // allow paddle webhook, without auth tokens
                if r.URL.Path == "/users/subscription/webhook" </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">token, err := r.Cookie("access_token")

                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">claims, err := auth.ValidateToken(token.Value)

                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)

                        return
                }</span>

                <span class="cov0" title="0">_, emailOK := claims["sub"]
                userId, userIdOK := claims["user_id"].(string)
                _, sIdOK := claims["session_id"]
                expiryTime, expiryOK := claims["exp"].(float64)

                if !emailOK || !sIdOK || !expiryOK || !userIdOK </span><span class="cov0" title="0">{
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">if int64(expiryTime) &lt; time.Now().Unix() </span><span class="cov0" title="0">{
                        // token expired, redirect to login
                        http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        return
                }</span>

                // token valid, allow
                <span class="cov0" title="0">r.Header.Set("UserId", userId)

                next.ServeHTTP(w, r)</span>
        })
}

func main() <span class="cov0" title="0">{

        // load config
        config.Init()

        mux := http.NewServeMux()

        ddb := db.New()
        emailQueue := events.NewEmailQueue()
        // client := &amp;http.Client{}

        client := http.DefaultClient

        mux.Handle("/auth/", auth.Router())
        mux.Handle("/users/", authorizer(users.Router(ddb, emailQueue, client)))
        mux.Handle("/spaces/", authorizer(spaces.Router()))
        mux.Handle("/notes/", authorizer(notes.Router()))
        mux.Handle("/notifications/", authorizer(notifications.Router()))

        // handle unknown service routes
        mux.Handle("/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Error(w, "Unknown Service", http.StatusNotFound)
        }</span>))

        <span class="cov0" title="0">fmt.Println("Running auth service on port 8080")

        err := http.ListenAndServe(":8080", mux)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error starting server:", err)
        }</span>

}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "github.com/aws/aws-lambda-go/lambda"
        "github.com/manishMandal02/tabsflow-backend/config"
        "github.com/manishMandal02/tabsflow-backend/internal/notes"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
)

func main() <span class="cov0" title="0">{

        // load config
        config.Init()

        handler := http_api.NewAPIGatewayHandler("/notes/", notes.Router())

        lambda.Start(handler.Handle)

}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "github.com/aws/aws-lambda-go/lambda"
        "github.com/manishMandal02/tabsflow-backend/config"
        "github.com/manishMandal02/tabsflow-backend/internal/notifications"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
)

func main() <span class="cov0" title="0">{

        // load config
        config.Init()

        handler := http_api.NewAPIGatewayHandlerWithSQSHandler("/notifications/", notifications.Router(), notifications.EventsHandler)

        lambda.Start(handler.Handle)

}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "github.com/aws/aws-lambda-go/lambda"
        "github.com/manishMandal02/tabsflow-backend/config"
        "github.com/manishMandal02/tabsflow-backend/internal/spaces"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
)

func main() <span class="cov0" title="0">{

        // load config
        config.Init()

        handler := http_api.NewAPIGatewayHandler("/spaces/", spaces.Router())

        lambda.Start(handler.Handle)

}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "net/http"

        "github.com/aws/aws-lambda-go/lambda"
        "github.com/manishMandal02/tabsflow-backend/config"
        "github.com/manishMandal02/tabsflow-backend/internal/users"
        "github.com/manishMandal02/tabsflow-backend/pkg/db"
        "github.com/manishMandal02/tabsflow-backend/pkg/events"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
)

func main() <span class="cov0" title="0">{
        // load config
        config.Init()

        ddb := db.New()

        queue := events.NewEmailQueue()

        client := &amp;http.Client{}

        handler := http_api.NewAPIGatewayHandler("/users/", users.Router(ddb, queue, client))

        lambda.Start(handler.Handle)

}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package config

import (
        "context"
        "flag"
        "log"
        "os"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/aws/retry"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/joho/godotenv"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

var (
        AWS_REGION                  string
        JWT_SECRET_KEY              string
        EMAIL_QUEUE_URL             string
        NOTIFICATIONS_QUEUE_URL     string
        NOTIFICATIONS_QUEUE_ARN     string
        SCHEDULER_ROLE_ARN          string
        DDB_MAIN_TABLE_NAME         string
        DDB_SEARCH_INDEX_TABLE_NAME string
        DDB_SESSIONS_TABLE_NAME     string
        ZEPTO_MAIL_API_KEY          string
        PADDLE_API_KEY              string
        PADDLE_WEBHOOK_SECRET_KEY   string
        VAPID_PRIVATE_KEY           string
        VAPID_PUBLIC_KEY            string
        AWS_CONFIG                  aws.Config
        LOCAL_DEV_ENV               = false
)

const (
        TRAIL_DAYS               = 14
        OTP_EXPIRY_TIME_IN_MIN   = 5
        JWT_TOKEN_EXPIRY_IN_DAYS = 10
        USER_SESSION_EXPIRY_DAYS = 10
        DATE_TIME_FORMAT         = "2006-01-02T15:04:05"
        ZEPTO_MAIL_API_URL       = "https://api.zeptomail.in/v1.1/email/template"
)

func Init() <span class="cov0" title="0">{

        localDevFlag := flag.Bool("local_dev", false, "local development mode")

        flag.Parse()

        isLocalDev := *localDevFlag

        if isLocalDev </span><span class="cov0" title="0">{
                logger.Info("Local development mode 🚧")
                LOCAL_DEV_ENV = true
                err := godotenv.Load()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("Error loading .env file")
                }</span>

                // local development config
                <span class="cov0" title="0">profile := os.Getenv("AWS_ACCOUNT_PROFILE")

                config, err := config.LoadDefaultConfig(context.Background(),
                        config.WithSharedConfigProfile(profile),
                        config.WithRetryer(func() aws.Retryer </span><span class="cov0" title="0">{
                                return retry.AddWithMaxAttempts(retry.NewStandard(), 20)
                        }</span>),
                )

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to load configuration, %v", err)
                }</span>
                <span class="cov0" title="0">AWS_CONFIG = config

                DDB_MAIN_TABLE_NAME = "TabsFlow-Main_dev"
                DDB_SEARCH_INDEX_TABLE_NAME = "TabsFlow-SearchIndex_dev"
                DDB_SESSIONS_TABLE_NAME = "TabsFlow-Sessions_dev"
                EMAIL_QUEUE_URL = "TabsFlow-Emails_dev"
                NOTIFICATIONS_QUEUE_URL = "TabsFlow-Notifications_dev"</span>
        } else<span class="cov0" title="0"> {
                // lambda config
                config, err := config.LoadDefaultConfig(context.Background(),
                        config.WithRegion(AWS_REGION),

                        config.WithRetryer(func() aws.Retryer </span><span class="cov0" title="0">{
                                return retry.AddWithMaxAttempts(retry.NewStandard(), 25)
                        }</span>),
                )

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to load configuration, %v", err)
                }</span>

                <span class="cov0" title="0">AWS_CONFIG = config

                DDB_MAIN_TABLE_NAME = os.Getenv("DDB_MAIN_TABLE_NAME")
                DDB_SESSIONS_TABLE_NAME = os.Getenv("DDB_SESSIONS_TABLE_NAME")
                DDB_SEARCH_INDEX_TABLE_NAME = os.Getenv("DDB_SEARCH_INDEX_TABLE_NAME")
                EMAIL_QUEUE_URL = os.Getenv("EMAIL_QUEUE_URL")
                NOTIFICATIONS_QUEUE_URL = os.Getenv("NOTIFICATIONS_QUEUE_URL")
                SCHEDULER_ROLE_ARN = os.Getenv("SCHEDULER_ROLE_ARN")
                NOTIFICATIONS_QUEUE_ARN = os.Getenv("NOTIFICATIONS_QUEUE_ARN")</span>
        }

        <span class="cov0" title="0">AWS_REGION = os.Getenv("AWS_REGION")
        JWT_SECRET_KEY = os.Getenv("JWT_SECRET_KEY")
        ZEPTO_MAIL_API_KEY = os.Getenv("ZEPTO_MAIL_API_KEY")
        PADDLE_API_KEY = os.Getenv("PADDLE_API_KEY")
        PADDLE_WEBHOOK_SECRET_KEY = os.Getenv("PADDLE_WEBHOOK_SECRET_KEY")
        VAPID_PRIVATE_KEY = os.Getenv("VAPID_PRIVATE_KEY")
        VAPID_PUBLIC_KEY = os.Getenv("VAPID_PUBLIC_KEY")</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package auth

import (
        "encoding/json"
        "errors"
        "net/http"
        "strings"
        "time"

        lambda_events "github.com/aws/aws-lambda-go/events"

        "github.com/manishMandal02/tabsflow-backend/config"
        "github.com/manishMandal02/tabsflow-backend/pkg/events"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
        "github.com/manishMandal02/tabsflow-backend/pkg/utils"
)

// if userId not found in Session table, add user profile (U#Profile) to main table

type authHandler struct {
        r authRepository
}

func newAuthHandler(repo authRepository) *authHandler <span class="cov0" title="0">{
        return &amp;authHandler{
                r: repo,
        }
}</span>

func (h *authHandler) sendOTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var b struct {
                Email string `json:"email"`
        }

        r.Body = http.MaxBytesReader(w, r.Body, 1048576)

        decoder := json.NewDecoder(r.Body)
        err := decoder.Decode(&amp;b)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error decoding request body for sendOTP", err)
                http.Error(w, errMsg.sendOTP, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">otp := utils.GenerateOTP()

        err = h.r.saveOTP(&amp;emailOTP{
                OTP:   otp,
                Email: b.Email,
                TTL:   time.Now().Add(time.Minute * time.Duration(config.OTP_EXPIRY_TIME_IN_MIN)).Unix(),
        })

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, errMsg.sendOTP, http.StatusBadGateway)
                return
        }</span>

        // send email message to SQS queue
        // send USER_REGISTERED event to email service (queue)
        <span class="cov0" title="0">event := events.New(events.EventTypeSendOTP, &amp;events.SendOTPPayload{
                Email: b.Email,
                OTP:   otp,
        })

        sqs := events.NewEmailQueue()

        err = sqs.AddMessage(event)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, errMsg.sendOTP, http.StatusBadGateway)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResMsg(w, "OTP sent successfully")</span>

}

func (h *authHandler) verifyOTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var b struct {
                Email string `json:"email"`
                OTP   string `json:"otp"`
        }

        r.Body = http.MaxBytesReader(w, r.Body, 1048576)

        err := json.NewDecoder(r.Body).Decode(&amp;b)

        userAgent := r.Header.Get("User-Agent")

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error decoding request body for verify otp", err)
                http.Error(w, errMsg.validateOTP, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">valid, err := h.r.validateOTP(b.Email, b.OTP)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, errMsg.validateOTP, http.StatusBadGateway)
                return
        }</span>

        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                http.Error(w, errMsg.inValidOTP, http.StatusBadRequest)
                return
        }</span>

        // create new session and set to cookie
        <span class="cov0" title="0">res, err := createNewSession(b.Email, userAgent, h.r)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, errMsg.createSession, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">http.SetCookie(w, res.cookie)
        http_api.SuccessResMsgWithBody(w, "OTP verified successfully", res.data)</span>
}

func (h *authHandler) googleAuth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var b struct {
                Email string `json:"email"`
        }

        userAgent := r.Header.Get("User-Agent")

        decoder := json.NewDecoder(r.Body)

        err := decoder.Decode(&amp;b)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error decoding request body for google auth", err)
                http.Error(w, errMsg.googleAuth, http.StatusBadRequest)
                return
        }</span>

        // create new session and set to cookie
        <span class="cov0" title="0">res, err := createNewSession(b.Email, userAgent, h.r)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(errMsg.createSession, errors.New(errMsg.createSession))
                return
        }</span>

        <span class="cov0" title="0">http.SetCookie(w, res.cookie)
        http.SetCookie(w, res.cookie)
        http_api.SuccessResMsgWithBody(w, "OTP verified successfully", res.data)</span>
}

func (h *authHandler) getUserId(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var b struct {
                Email string `json:"email"`
        }

        decoder := json.NewDecoder(r.Body)
        err := decoder.Decode(&amp;b)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error decoding request body for getUserId", err)
                http.Error(w, errMsg.getUserId, http.StatusBadRequest)
        }</span>
        <span class="cov0" title="0">userId, err := h.r.userIdByEmail(b.Email)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, errMsg.getUserId, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if userId == "" </span><span class="cov0" title="0">{
                http.Error(w, "No user with given email", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">resData := &amp;struct {
                UserId string `json:"userId"`
        }{
                UserId: userId,
        }

        http_api.SuccessResData(w, resData)</span>
}

func (h *authHandler) logout(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        logoutResponse := func() </span><span class="cov0" title="0">{
                cookie := &amp;http.Cookie{
                        Name:     "access_token",
                        Value:    "",
                        HttpOnly: true,
                        Secure:   true,
                        Path:     "/",
                        MaxAge:   -1,
                }

                http.SetCookie(w, cookie)

                http_api.SuccessResMsg(w, "logged out successfully")
        }</span>

        <span class="cov0" title="0">c, err := r.Cookie("access_token")

        if err != nil </span><span class="cov0" title="0">{
                logoutResponse()
                return
        }</span>

        <span class="cov0" title="0">claims, err := ValidateToken(c.Value)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(errMsg.validateSession, err)
                logoutResponse()
                return
        }</span>

        <span class="cov0" title="0">email, okEmail := claims["sub"].(string)
        sId, okSID := claims["session_id"].(string)

        if !okEmail || !okSID </span><span class="cov0" title="0">{
                logger.Error(errMsg.validateSession, errors.New(errMsg.invalidToken))
                logoutResponse()
                return
        }</span>

        <span class="cov0" title="0">err = h.r.deleteSession(email, sId)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(errMsg.deleteSession, err)
                logoutResponse()
                return
        }</span>

        <span class="cov0" title="0">logoutResponse()</span>
}

func (h *authHandler) lambdaAuthorizer(ev *lambda_events.APIGatewayCustomAuthorizerRequestTypeRequest) (*lambda_events.APIGatewayCustomAuthorizerResponse, error) <span class="cov0" title="0">{

        // allow paddle webhook url, without auth tokens
        if strings.Contains(ev.Path, "/users/subscription/webhook") </span><span class="cov0" title="0">{
                //  allow access
                return generatePolicy("paddle-webhook", "Allow", ev.MethodArn, "", nil), nil
        }</span>

        <span class="cov0" title="0">cookies := parseCookiesStr(ev.Headers["Cookie"])

        claims, err := ValidateToken(cookies["access_token"])

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error validating JWT token", errors.New(errMsg.invalidToken))

                return nil, errors.New("Unauthorized")
        }</span>

        <span class="cov0" title="0">email, emailOK := claims["sub"].(string)
        userId, userIdOK := claims["user_id"].(string)
        sId, sIdOK := claims["session_id"].(string)
        expiryTime, expiryOK := claims["exp"].(float64)

        if !emailOK || !sIdOK || !expiryOK || !userIdOK </span><span class="cov0" title="0">{
                logger.Error("Error getting token claims", errors.New(errMsg.invalidToken))
                return nil, errors.New("Unauthorized")
        }</span>

        <span class="cov0" title="0">if int64(expiryTime) &gt; time.Now().Unix() </span><span class="cov0" title="0">{
                // token valid, allow access
                return generatePolicy(userId, "Allow", ev.MethodArn, userId, nil), nil
        }</span>

        // validate session
        <span class="cov0" title="0">isValid, err := h.r.validateSession(email, sId)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error validating session", errors.New(errMsg.validateSession))
                return nil, errors.New("Unauthorized")
        }</span>

        // if session, valid then refresh token and allow access
        <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                logger.Error("Error validating session", errors.New(errMsg.validateSession))
                return nil, errors.New("Unauthorized")
        }</span>

        <span class="cov0" title="0">res, err := createNewSession(email, ev.Headers["User-Agent"], h.r)

        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("Unauthorized")
        }</span>

        <span class="cov0" title="0">newCookies := map[string]string{
                "access_token": res.token,
        }

        return generatePolicy(userId, "Allow", ev.MethodArn, userId, newCookies), nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package auth

import (
        "errors"
        "fmt"
        "net/http"
        "strings"
        "time"

        lambda_events "github.com/aws/aws-lambda-go/events"
        jwt "github.com/golang-jwt/jwt/v5"
        "github.com/mssola/useragent"

        "github.com/manishMandal02/tabsflow-backend/config"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
        "github.com/manishMandal02/tabsflow-backend/pkg/utils"
)

// * helpers
// generate new token
func generateToken(email, userId, sessionId string) (string, error) <span class="cov0" title="0">{
        // Create a new JWT token with claims
        claims := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                // Subject (user email)
                "sub":        email,
                "user_id":    userId,
                "session_id": sessionId,
                // Issuer
                "iss": "tabsflow-app",
                // Expiration time
                "exp": time.Now().AddDate(0, 0, config.JWT_TOKEN_EXPIRY_IN_DAYS).Unix(),
                // Issued at
                "iat": time.Now().Unix(),
        })

        tokenStr, err := claims.SignedString([]byte(config.JWT_SECRET_KEY))

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error generating JWT token", err)
                return "", err
        }</span>

        <span class="cov0" title="0">return tokenStr, nil</span>
}

// validate jwt token
func ValidateToken(tokenStr string) (jwt.MapClaims, error) <span class="cov0" title="0">{

        token, err := jwt.Parse(tokenStr, func(_ *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(config.JWT_SECRET_KEY), nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error parsing JWT token", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token")
        }</span>

        <span class="cov0" title="0">return token.Claims.(jwt.MapClaims), nil</span>
}

// parse cookie
func parseCookiesStr(cookieHeader string) map[string]string <span class="cov0" title="0">{
        cookies := make(map[string]string)
        if cookieHeader == "" </span><span class="cov0" title="0">{
                return cookies
        }</span>
        <span class="cov0" title="0">pairs := strings.Split(cookieHeader, ";")
        for _, pair := range pairs </span><span class="cov0" title="0">{
                parts := strings.SplitN(strings.TrimSpace(pair), "=", 2)
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        cookies[parts[0]] = parts[1]
                }</span>
        }
        <span class="cov0" title="0">return cookies</span>
}

type createSessionRes struct {
        token  string
        cookie *http.Cookie
        data   struct {
                UserId  string `json:"userId"`
                NewUser bool   `json:"isNewUser"`
        }
}

func createNewSession(email, userAgent string, aR authRepository) (*createSessionRes, error) <span class="cov0" title="0">{

        //  check if user exits
        userId, err := aR.userIdByEmail(email)

        type respData struct {
                UserId  string `json:"userId"`
                NewUser bool   `json:"isNewUser"`
        }

        var resData *respData

        if err != nil || userId == "" </span><span class="cov0" title="0">{
                // new user
                newUserId := utils.GenerateID()

                err = aR.attachUserId(&amp;emailWithUserId{
                        Email:  email,
                        UserId: newUserId,
                })

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">resData = &amp;respData{
                        UserId:  newUserId,
                        NewUser: true,
                }

                userId = newUserId</span>
        } else<span class="cov0" title="0"> {
                // old user
                resData = &amp;respData{
                        UserId:  userId,
                        NewUser: false,
                }

        }</span>

        <span class="cov0" title="0">ua := useragent.New(userAgent)

        browser, _ := ua.Browser()

        session := session{
                Email: email,
                Id:    utils.GenerateRandomString(20),
                TTL:   time.Now().AddDate(0, 0, config.USER_SESSION_EXPIRY_DAYS*3).Unix(),
                DeviceInfo: &amp;deviceInfo{
                        Browser:  browser,
                        OS:       ua.OS(),
                        Platform: ua.Platform(),
                        IsMobile: ua.Mobile(),
                },
        }

        err = aR.createSession(&amp;session)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(errMsg.createSession, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">newToken, err := generateToken(email, userId, session.Id)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error(errMsg.createToken, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">cookie := &amp;http.Cookie{
                Name:     "access_token",
                Value:    newToken,
                HttpOnly: true,
                Secure:   true,
                Path:     "/",
                SameSite: http.SameSiteLaxMode,
        }

        return &amp;createSessionRes{
                cookie: cookie,
                data:   *resData,
        }, nil</span>
}

// generate policy for lambda authorizer
func generatePolicy(principalId, effect, methodArn, userId string, cookies map[string]string) *lambda_events.APIGatewayCustomAuthorizerResponse <span class="cov0" title="0">{

        // remove the path and method from the arn, so it allows all the path and method even with cached data
        arnParts := strings.Split(methodArn, ":")
        apiGatewayArnTmp := strings.Split(arnParts[5], "/")
        apiID := apiGatewayArnTmp[0] // This gets just the API ID
        wildcardArn := fmt.Sprintf("arn:aws:execute-api:%s:%s:%s/%s/*",
                arnParts[3],         // region
                arnParts[4],         // account ID
                apiID,               // API ID
                apiGatewayArnTmp[1], // stage
        )

        authResponse := lambda_events.APIGatewayCustomAuthorizerResponse{PrincipalID: principalId}

        if effect != "" &amp;&amp; methodArn != "" </span><span class="cov0" title="0">{
                authResponse.PolicyDocument = lambda_events.APIGatewayCustomAuthorizerPolicy{
                        Version: "2012-10-17",
                        Statement: []lambda_events.IAMPolicyStatement{
                                {
                                        Action:   []string{"execute-api:Invoke"},
                                        Effect:   effect,
                                        Resource: []string{wildcardArn},
                                },
                        },
                }
        }</span>

        <span class="cov0" title="0">if cookies != nil </span><span class="cov0" title="0">{
                cookieStrings := make([]string, 0, len(cookies))
                for key, value := range cookies </span><span class="cov0" title="0">{
                        cookieStrings = append(cookieStrings, fmt.Sprintf("%s=%s; HttpOnly; Secure; SameSite=Strict; Expires:%v", key, value, time.Now().AddDate(0, 0, config.USER_SESSION_EXPIRY_DAYS*3).Format(time.RFC1123)))
                }</span>
                <span class="cov0" title="0">authResponse.Context = map[string]interface{}{
                        "Set-Cookie": strings.Join(cookieStrings, ", "),
                }</span>
        }

        <span class="cov0" title="0">if userId != "" </span><span class="cov0" title="0">{
                if authResponse.Context == nil </span><span class="cov0" title="0">{
                        authResponse.Context = map[string]interface{}{}
                }</span>
                <span class="cov0" title="0">authResponse.Context["UserId"] = userId</span>
        }

        <span class="cov0" title="0">if effect != "Allow" </span><span class="cov0" title="0">{

                if authResponse.Context == nil </span><span class="cov0" title="0">{
                        authResponse.Context = map[string]interface{}{}
                }</span>
                <span class="cov0" title="0">authResponse.Context["code"] = "401"
                authResponse.Context["message"] = "Unauthorized"</span>
        }

        <span class="cov0" title="0">logger.Dev("authorizer response: %v", authResponse)

        return &amp;authResponse</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package auth

import (
        "context"
        "errors"
        "strconv"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
        "github.com/manishMandal02/tabsflow-backend/pkg/db"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

type authRepository interface {
        saveOTP(data *emailOTP) error
        attachUserId(data *emailWithUserId) error
        userIdByEmail(email string) (string, error)
        validateOTP(email, otp string) (bool, error)
        validateSession(email, id string) (bool, error)
        createSession(s *session) error
        deleteSession(email, sessionId string) error
}

type authRepo struct {
        db *db.DDB
}

func newAuthRepository(db *db.DDB) authRepository <span class="cov0" title="0">{
        return &amp;authRepo{
                db: db,
        }
}</span>

// save OTP to DB
func (r *authRepo) saveOTP(data *emailOTP) error <span class="cov0" title="0">{

        ttl := strconv.FormatInt(data.TTL, 10)

        saveItem := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: data.Email},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY_SESSIONS.OTP(data.OTP)},
                "TTL":      &amp;types.AttributeValueMemberS{Value: ttl},
        }

        _, err := r.db.Client.PutItem(context.TODO(), &amp;dynamodb.PutItemInput{
                TableName: &amp;r.db.TableName,
                Item:      saveItem,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't save OTP to db for email: %v, \n[Error:] %v", data.Email, err)
                return errors.New(errMsg.sendOTP)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *authRepo) validateOTP(email, otp string) (bool, error) <span class="cov0" title="0">{

        // primary key - partition+sort key
        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: email},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY_SESSIONS.OTP(otp)},
        }

        response, err := r.db.Client.GetItem(context.TODO(), &amp;dynamodb.GetItemInput{
                TableName: &amp;r.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get OTP from db for email: %#v: \n[Error]: %v", email, err)
                return false, errors.New(errMsg.validateOTP)
        }</span>

        <span class="cov0" title="0">if response.Item == nil || response.Item["TTL"] == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // check if OTP has expired
        <span class="cov0" title="0">var ttl struct {
                TTL string
        }

        err = attributevalue.UnmarshalMap(response.Item, &amp;ttl)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal OTP ttl from db for email: %#v: \n[Error]: %v", email, err)
                return false, errors.New(errMsg.inValidOTP)
        }</span>

        <span class="cov0" title="0">ttlInt, err := strconv.ParseInt(ttl.TTL, 10, 64)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't convert TTL to int for email: %#v: \n[Error]: %v", email, err)
                return false, errors.New(errMsg.inValidOTP)
        }</span>

        <span class="cov0" title="0">if ttlInt &lt; int64(time.Now().Unix()) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

func (r *authRepo) attachUserId(data *emailWithUserId) error <span class="cov0" title="0">{
        // primary key - partition+sort key
        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: data.Email},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY_SESSIONS.UserId(data.UserId)},
        }

        _, err := r.db.Client.PutItem(context.TODO(), &amp;dynamodb.PutItemInput{
                TableName: &amp;r.db.TableName,
                Item:      key,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't attach user id to email: %#v, \n[Error]: %v", data.Email, err)
                return errors.New(errMsg.createSession)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *authRepo) userIdByEmail(email string) (string, error) <span class="cov0" title="0">{
        // primary key - partition+sort key
        keyCondition := expression.KeyAnd(expression.Key("PK").Equal(expression.Value(email)), expression.Key("SK").BeginsWith(db.SORT_KEY_SESSIONS.UserId("")))

        expr, err := expression.NewBuilder().WithKeyCondition(keyCondition).Build()

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't build getUserID expression for email: %#v: \n[Error]: %v", email, err)
                return "", errors.New(errMsg.createSession)
        }</span>

        <span class="cov0" title="0">response, err := r.db.Client.Query(context.TODO(), &amp;dynamodb.QueryInput{
                TableName:                 &amp;r.db.TableName,
                ExpressionAttributeNames:  expr.Names(),
                ExpressionAttributeValues: expr.Values(),
                KeyConditionExpression:    expr.KeyCondition(),
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get user id from db for email: %#v: \n[Error]: %v", email, err)
                return "", errors.New(errMsg.getUserId)
        }</span>

        <span class="cov0" title="0">if len(response.Items) &lt; 1 </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">var s struct {
                UserId string `json:"userId" dynamodbav:"SK"`
        }

        err = attributevalue.UnmarshalMap(response.Items[0], &amp;s)

        if err != nil || s.UserId == "" </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal user id from db for email: %#v: \n[Error]: %v", email, err)
                return "", errors.New(errMsg.getUserId)
        }</span>

        // get user id from sort key
        <span class="cov0" title="0">userId := strings.Split(s.UserId, "#")[1]

        if userId == "" </span><span class="cov0" title="0">{
                // logger.Errorf("Couldn't get user id from sort_key: %#v", s: \n[Error]: %v.UserId, err)
                logger.Errorf("Couldn't get user id from sort_key: %#v: \n[Error]: %v", s.UserId, err)

                return "", nil
        }</span>

        <span class="cov0" title="0">return userId, nil</span>

}

func (r *authRepo) createSession(s *session) error <span class="cov0" title="0">{

        item := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: s.Email},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY_SESSIONS.Session(s.Id)},
                "TTL":      &amp;types.AttributeValueMemberS{Value: strconv.FormatInt(s.TTL, 10)},
                "DeviceInfo": &amp;types.AttributeValueMemberM{
                        Value: map[string]types.AttributeValue{
                                "browser":  &amp;types.AttributeValueMemberS{Value: s.DeviceInfo.Browser},
                                "os":       &amp;types.AttributeValueMemberS{Value: s.DeviceInfo.OS},
                                "platform": &amp;types.AttributeValueMemberS{Value: s.DeviceInfo.Platform},
                                "isMobile": &amp;types.AttributeValueMemberBOOL{Value: s.DeviceInfo.IsMobile},
                        },
                },
        }

        _, err := r.db.Client.PutItem(context.TODO(), &amp;dynamodb.PutItemInput{
                TableName: &amp;r.db.TableName,
                Item:      item,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't create session for email: %#v. \n[Error]: %v", s.Email, err)
                return errors.New(errMsg.createSession)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *authRepo) deleteSession(email, id string) error <span class="cov0" title="0">{
        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: email},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY_SESSIONS.Session(id)},
        }

        _, err := r.db.Client.DeleteItem(context.TODO(), &amp;dynamodb.DeleteItemInput{
                TableName: &amp;r.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't delete session for user with email: %#v: \n[Error]: %v", email, err)

                return errors.New(errMsg.deleteSession)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *authRepo) validateSession(email, id string) (bool, error) <span class="cov0" title="0">{
        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: email},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY_SESSIONS.Session(id)},
        }

        response, err := r.db.Client.GetItem(context.TODO(), &amp;dynamodb.GetItemInput{
                TableName: &amp;r.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get session from db, for email: %#v: \n[Error]: %v", email, err)
                return false, errors.New(errMsg.validateSession)
        }</span>

        <span class="cov0" title="0">var userSession session

        err = attributevalue.UnmarshalMap(response.Item, &amp;userSession)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal session expiry from db for email: %#v: \n[Error]: %v", email, err)
                return false, errors.New(errMsg.validateSession)
        }</span>

        <span class="cov0" title="0">if userSession.Id == "" </span><span class="cov0" title="0">{
                return false, errors.New(errMsg.validateSession)
        }</span>

        <span class="cov0" title="0">if userSession.TTL &lt; time.Now().Unix() </span><span class="cov0" title="0">{
                return false, errors.New(errMsg.validateSession)
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package auth

import (
        lambda_events "github.com/aws/aws-lambda-go/events"
        "github.com/manishMandal02/tabsflow-backend/pkg/db"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
)

// custom API_GW lambda authorizer
func LambdaAuthorizer(ev *lambda_events.APIGatewayCustomAuthorizerRequestTypeRequest) (*lambda_events.APIGatewayCustomAuthorizerResponse, error) <span class="cov0" title="0">{

        db := db.NewSessionTable()
        ar := newAuthRepository(db)

        handler := newAuthHandler(ar)

        return handler.lambdaAuthorizer(ev)
}</span>

func Router() http_api.IRouter <span class="cov0" title="0">{

        db := db.NewSessionTable()

        ar := newAuthRepository(db)

        handler := newAuthHandler(ar)

        authRouter := http_api.NewRouter("/auth")

        // authRouter("/", handler.getUserId)

        authRouter.POST("/verify-otp", handler.verifyOTP)

        authRouter.POST("/send-otp", handler.sendOTP)

        authRouter.POST("/google", handler.googleAuth)

        authRouter.GET("/logout", handler.logout)

        authRouter.GET("/user", handler.getUserId)

        // serve API routes
        return authRouter
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package email

import (
        "context"
        "fmt"

        lambda_events "github.com/aws/aws-lambda-go/events"

        "github.com/manishMandal02/tabsflow-backend/pkg/events"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

func SendEmail(_ context.Context, event lambda_events.SQSEvent) (interface{}, error) <span class="cov0" title="0">{
        if len(event.Records) == 0 </span><span class="cov0" title="0">{
                err := fmt.Errorf("no records found in event")
                logger.Error(err.Error(), err)
                return nil, err
        }</span>
        //  process batch of events
        <span class="cov0" title="0">for _, record := range event.Records </span><span class="cov0" title="0">{
                event := events.Event[any]{}

                logger.Info("processing record: %v", record.Body)

                eventType := *record.MessageAttributes["event_type"].StringValue

                logger.Info("processing event_type: %v", event.EventType)

                err := processEvent(eventType, record.Body)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error processing event: %v", err)
                        continue</span>
                }

                // remove message from sqs
                <span class="cov0" title="0">q := events.NewEmailQueue()

                err = q.DeleteMessage(record.ReceiptHandle)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

        }

        <span class="cov0" title="0">return nil, nil</span>
}

func processEvent(eventType string, body string) error <span class="cov0" title="0">{

        switch events.EventType(eventType) </span>{
        case events.EventTypeSendOTP:<span class="cov0" title="0">

                ev, err := events.NewFromJSON[events.SendOTPPayload](body)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error un_marshalling event: %v", err)
                        return err
                }</span>

                <span class="cov0" title="0">return handleSendOTPMail(*ev.Payload)</span>

        case events.EventTypeUserRegistered:<span class="cov0" title="0">
                ev, err := events.NewFromJSON[events.UserRegisteredPayload](body)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error un_marshalling event: %v", err)
                        return err
                }</span>

                <span class="cov0" title="0">return handleUserRegistered(*ev.Payload)</span>

        default:<span class="cov0" title="0">
                logger.Errorf("Unknown sqs event: %v", eventType)</span>
        }

        <span class="cov0" title="0">return nil</span>

}

func handleSendOTPMail(payload events.SendOTPPayload) error <span class="cov0" title="0">{

        to := &amp;NameAddr{
                Name:    payload.Email,
                Address: payload.Email,
        }

        z := NewZeptoMail()

        otp := payload.OTP

        err := z.SendOTPMail(otp, to)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func handleUserRegistered(payload events.UserRegisteredPayload) error <span class="cov0" title="0">{
        z := NewZeptoMail()

        to := &amp;NameAddr{
                Name:    payload.Name,
                Address: payload.Email,
        }

        err := z.sendWelcomeMail(to, payload.TrailEndDate)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package email

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        "github.com/manishMandal02/tabsflow-backend/config"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
        "github.com/manishMandal02/tabsflow-backend/pkg/utils"
)

var ZeptoMailTemplates = map[string]string{
        "otp":     "2518b.5aadbc61a6c007b3.k1.9b26d2f0-7460-11ef-b8eb-525400ab18e6.191fc46a59f",
        "welcome": "2518b.5aadbc61a6c007b3.k1.98545e20-74c5-11ef-b8eb-525400ab18e6.191fedc7d02",
}

type NameAddr struct {
        Name    string `json:"name"`
        Address string `json:"address"`
}

type ToEmailAddress struct {
        EmailAddress NameAddr `json:"email_address"`
}

type ZeptoMailBody struct {
        TemplateKey string           `json:"template_key"`
        To          []ToEmailAddress `json:"to"`
        From        *NameAddr        `json:"from"`
}

type otpMergeInfo struct {
        OTP string `json:"OTP"`
}
type otpEmailBody struct {
        *ZeptoMailBody
        MergeInfo *otpMergeInfo `json:"merge_info"`
}

type ZeptoMail struct {
        URL     string
        APIKey  string
        Headers map[string]string
        From    *NameAddr
}

func NewZeptoMail() *ZeptoMail <span class="cov0" title="0">{

        headers := map[string]string{
                "Accept":        "application/json",
                "Content-Type":  "application/json",
                "Authorization": fmt.Sprintf("Zoho-enczapikey %v", strings.TrimSpace(config.ZEPTO_MAIL_API_KEY)),
        }

        return &amp;ZeptoMail{
                URL:     config.ZEPTO_MAIL_API_URL,
                APIKey:  config.ZEPTO_MAIL_API_KEY,
                Headers: headers,
                From: &amp;NameAddr{
                        Name:    "TabsFlow Support",
                        Address: "support@tabsflow.com",
                },
        }
}</span>

func (z *ZeptoMail) SendOTPMail(otp string, to *NameAddr) error <span class="cov0" title="0">{

        body := &amp;otpEmailBody{
                ZeptoMailBody: &amp;ZeptoMailBody{
                        TemplateKey: ZeptoMailTemplates["otp"],
                        To: append(
                                []ToEmailAddress{},
                                ToEmailAddress{
                                        EmailAddress: *to,
                                },
                        ),
                        From: &amp;NameAddr{
                                Name:    z.From.Name,
                                Address: z.From.Address,
                        },
                },
                MergeInfo: &amp;otpMergeInfo{
                        OTP: otp,
                },
        }

        bodyBytes, err := json.Marshal(body)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = sendMail(z.URL, z.Headers, bodyBytes)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type welcomeMergeInfo struct {
        Name         string `json:"name"`
        TrailEndDate string `json:"trail_end_date"`
        TrailEndLink string `json:"trail_end_link"`
}
type welcomeEmailBody struct {
        *ZeptoMailBody
        MergeInfo *welcomeMergeInfo `json:"merge_info"`
}

func (z *ZeptoMail) sendWelcomeMail(to *NameAddr, trailEndDate string) error <span class="cov0" title="0">{

        body := &amp;welcomeEmailBody{
                ZeptoMailBody: &amp;ZeptoMailBody{
                        TemplateKey: ZeptoMailTemplates["welcome"],
                        To: append(
                                []ToEmailAddress{},
                                ToEmailAddress{
                                        EmailAddress: *to,
                                },
                        ),
                        From: &amp;NameAddr{
                                Name:    z.From.Name,
                                Address: z.From.Address,
                        },
                },
                MergeInfo: &amp;welcomeMergeInfo{
                        Name:         to.Name,
                        TrailEndDate: trailEndDate,
                        TrailEndLink: "https://tabsflow.com/",
                },
        }

        bodyBytes, err := json.Marshal(body)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = sendMail(z.URL, z.Headers, bodyBytes)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// helper
func sendMail(url string, headers map[string]string, body []byte) error <span class="cov0" title="0">{
        res, respBody, err := utils.MakeHTTPRequest(http.MethodPost, url, headers, body, http.DefaultClient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("[email_service] Error sending email. Request body: %s, [Error]: %v", string(body), err)
                return err
        }</span>

        <span class="cov0" title="0">if res.StatusCode != http.StatusOK &amp;&amp; res.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                logger.Errorf("[email_service] Unsuccessful response from ZeptoMail. Status: %s, Body: %s", res.Status, respBody)
                return fmt.Errorf("unsuccessful response from ZeptoMail: %s", res.Status)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package notes

import (
        "encoding/json"
        "errors"
        "net/http"
        "strconv"
        "strings"

        "github.com/kljensen/snowball"
        "github.com/manishMandal02/tabsflow-backend/pkg/events"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

type noteHandler struct {
        r noteRepository
}

func newNoteHandler(nr noteRepository) *noteHandler <span class="cov0" title="0">{
        return &amp;noteHandler{
                r: nr,
        }
}</span>

func (h noteHandler) create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")

        note := &amp;Note{}

        err := json.NewDecoder(r.Body).Decode(note)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error decoding note: %v. [Error]: %v", note, err)
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = note.validate()

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">noteText, err := getNotesTextFromNoteJSON(note.Text)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error getting note text from note json: %v. [Error]: %v", note, err)
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.r.createNote(userId, note)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // index search terms in search table
        <span class="cov0" title="0">terms :=
                extractSearchTerms(note.Title, noteText, note.Domain)

        logger.Dev("num of search terms: %v", len(terms))

        err = h.r.indexSearchTerms(userId, note.Id, terms)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error indexing search terms for note: %v. [Error]: %v", note, err)
        }</span>

        //  if remainder is set, create a schedule to send reminder
        <span class="cov0" title="0">if note.RemainderAt != 0 </span><span class="cov0" title="0">{
                event := events.New(events.EventTypeScheduleNoteRemainder, &amp;events.ScheduleNoteRemainderPayload{
                        UserId:    userId,
                        NoteId:    note.Id,
                        SubEvent:  events.SubEventCreate,
                        TriggerAt: note.RemainderAt,
                })
                err = events.NewNotificationQueue().AddMessage(event)

                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, errMsg.noteCreate, http.StatusBadGateway)
                        return
                }</span>
        }

        <span class="cov0" title="0">http_api.SuccessResMsg(w, "Note created successfully")</span>
}

func (h noteHandler) get(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")

        noteId := r.PathValue("noteId")

        if noteId == "" </span><span class="cov0" title="0">{
                http.Error(w, errMsg.noteId, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">notes, err := h.r.GetNote(userId, noteId)

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == errMsg.notesGetEmpty </span><span class="cov0" title="0">{
                        http.Error(w, errMsg.notesGetEmpty, http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, err.Error(), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">http_api.SuccessResData(w, notes)</span>
}

func (h noteHandler) getAllByUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")

        lastNoteIdStr := r.URL.Query().Get("lastNoteId")

        var lastNoteId int64
        var err error

        if lastNoteIdStr != "" </span><span class="cov0" title="0">{
                lastNoteId, err = strconv.ParseInt(lastNoteIdStr, 10, 64)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Couldn't parse noteId", err)
                        http.Error(w, errMsg.noteGet, http.StatusBadRequest)
                        return
                }</span>
        }
        <span class="cov0" title="0">note, err := h.r.getNotesByUser(userId, lastNoteId)

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == errMsg.notesGetEmpty </span><span class="cov0" title="0">{
                        http.Error(w, errMsg.notesGetEmpty, http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, errMsg.notesGet, http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">http_api.SuccessResData(w, note)</span>

}

func (h noteHandler) search(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")
        query := r.URL.Query().Get("query")
        maxSearchLimit := r.URL.Query().Get("limit")

        if query == "" </span><span class="cov0" title="0">{
                http.Error(w, "search query required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">searchTerms := strings.Fields(query)

        limit := 8

        if maxSearchLimit != "" </span><span class="cov0" title="0">{
                n, err := strconv.ParseInt(maxSearchLimit, 10, 32)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Couldn't parse search limit query", err)
                        http.Error(w, errMsg.notesSearch, http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">if int(n) &gt; 10 || int(n) &lt; 2 </span><span class="cov0" title="0">{
                        limit = 10
                }</span> else<span class="cov0" title="0"> {
                        limit = int(n)
                }</span>
        }
        <span class="cov0" title="0">logger.Dev("searchTerms: %v", searchTerms)

        notesIds, err := getNoteIdsBySearchTerms(userId, searchTerms, limit, h.r)

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == errMsg.notesSearchEmpty </span><span class="cov0" title="0">{
                        http.Error(w, errMsg.notesSearchEmpty, http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, errMsg.notesSearch, http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">logger.Dev("final notesIds: %v", notesIds)

        // get notes that matched the search query
        notes, err := h.r.getNotesByIds(userId, &amp;notesIds)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, errMsg.notesSearch, http.StatusBadGateway)
                return
        }</span>

        <span class="cov0" title="0">if len(*notes) == 0 </span><span class="cov0" title="0">{
                http.Error(w, errMsg.notesSearchEmpty, http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResData(w, notes)</span>
}

func (h noteHandler) update(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")

        body := struct {
                *Note
        }{}

        err := json.NewDecoder(r.Body).Decode(&amp;body)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, errMsg.noteUpdate, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if body.Note.Id == "" </span><span class="cov0" title="0">{
                http.Error(w, errMsg.noteId, http.StatusBadRequest)
                return
        }</span>

        // get old note
        <span class="cov0" title="0">oldNote, err := h.r.GetNote(userId, body.Note.Id)

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == errMsg.notesGetEmpty </span><span class="cov0" title="0">{
                        http.Error(w, errMsg.notesGetEmpty, http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, errMsg.noteUpdate, http.StatusInternalServerError)
                return</span>

        }

        <span class="cov0" title="0">err = h.r.updateNote(userId, body.Note)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        // if remainder is updated/removed, update/delete the schedule if it has been set previously
        <span class="cov0" title="0">if oldNote.RemainderAt != body.Note.RemainderAt </span><span class="cov0" title="0">{
                if body.Note.RemainderAt != 0 </span><span class="cov0" title="0">{
                        // update schedule
                        event := events.New(events.EventTypeScheduleNoteRemainder, &amp;events.ScheduleNoteRemainderPayload{
                                NoteId:    body.Note.Id,
                                SubEvent:  events.SubEventUpdate,
                                TriggerAt: body.Note.RemainderAt,
                        })
                        err = events.NewNotificationQueue().AddMessage(event)
                }</span>

                <span class="cov0" title="0">if body.Note.RemainderAt == 0 </span><span class="cov0" title="0">{
                        // delete schedule
                        event := events.New(events.EventTypeScheduleNoteRemainder, &amp;events.ScheduleNoteRemainderPayload{
                                NoteId:   body.Note.Id,
                                SubEvent: events.SubEventDelete,
                        })
                        err = events.NewNotificationQueue().AddMessage(event)
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error scheduling note  noteId: %v. \n[Error]: %v", body.Note.Id, err)
                        http.Error(w, errMsg.noteUpdate, http.StatusBadRequest)
                        return
                }</span>

        }

        //  if title, note or domain is updated, re-index search terms
        <span class="cov0" title="0">if oldNote.Domain != body.Note.Domain || oldNote.Title != body.Note.Title || oldNote.Text != body.Note.Text </span><span class="cov0" title="0">{

                noteText, err := getNotesTextFromNoteJSON(oldNote.Text)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error getting note text from note json: %v. \n[Error]: %v", body.Note.Id, err)
                        http.Error(w, errMsg.noteUpdate, http.StatusBadRequest)
                        return
                }</span>

                // delete previous search terms
                <span class="cov0" title="0">oldTerms := extractSearchTerms(oldNote.Title, noteText, oldNote.Domain)

                err = h.r.deleteSearchTerms(userId, oldNote.Id, oldTerms)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error deleting search terms for noteId: %v. \n[Error]: %v", body.Note.Id, err)
                        http.Error(w, errMsg.noteUpdate, http.StatusBadGateway)
                        return
                }</span>

                // index new search terms for note
                <span class="cov0" title="0">terms := extractSearchTerms(body.Note.Title, noteText, body.Note.Domain)
                err = h.r.indexSearchTerms(userId, body.Note.Id, terms)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error indexing search terms for noteId: %v. \n[Error]: %v", body.Note.Id, err)
                        http.Error(w, errMsg.noteUpdate, http.StatusBadGateway)
                        return
                }</span>

        }

        <span class="cov0" title="0">http_api.SuccessResMsg(w, "Note updated successfully")</span>

}

func (h noteHandler) delete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")
        noteId := r.PathValue("noteId")

        if noteId == "" </span><span class="cov0" title="0">{
                http.Error(w, errMsg.noteId, http.StatusBadRequest)
                return
        }</span>

        // get old note
        <span class="cov0" title="0">noteToDelete, err := h.r.GetNote(userId, noteId)

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == errMsg.notesGetEmpty </span><span class="cov0" title="0">{
                        http.Error(w, errMsg.notesGetEmpty, http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, errMsg.noteUpdate, http.StatusInternalServerError)
                return</span>

        }

        <span class="cov0" title="0">err = h.r.deleteNote(userId, noteId)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        //  if remainder was set and schedule was created, then delete it
        <span class="cov0" title="0">if noteToDelete.RemainderAt != 0 </span><span class="cov0" title="0">{
                event := events.New(events.EventTypeScheduleNoteRemainder, &amp;events.ScheduleNoteRemainderPayload{
                        NoteId:   noteToDelete.Id,
                        SubEvent: events.SubEventDelete,
                })
                err = events.NewNotificationQueue().AddMessage(event)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error sending delete schedule for  noteId: %v. \n[Error]: %v", noteToDelete.Id, err)
                }</span>
        }

        // delete search terms
        <span class="cov0" title="0">noteText, err := getNotesTextFromNoteJSON(noteToDelete.Text)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error getting note text from note json for noteId: %v. \n[Error]: %v", noteToDelete.Id, err)
        }</span>

        <span class="cov0" title="0">terms := extractSearchTerms(noteToDelete.Title, noteText, noteToDelete.Domain)

        if len(terms) &lt; 1 </span><span class="cov0" title="0">{
                logger.Errorf("error getting search terms for noteId: %v. \n[Error]: %v", noteToDelete.Id, err)
        }</span>

        <span class="cov0" title="0">logger.Dev("num of search terms: %v", len(terms))

        err = h.r.deleteSearchTerms(userId, noteId, terms)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error deleting search terms for noteId: %v. \n[Error]: %v", noteId, err)
        }</span>

        <span class="cov0" title="0">http_api.SuccessResMsg(w, "Note deleted successfully")</span>

}

//* helpers

func recursiveNoteTextParser(d map[string]interface{}) string <span class="cov0" title="0">{
        text := ""
        if d["type"] == "text" </span><span class="cov0" title="0">{
                text = d["text"].(string)
        }</span>
        <span class="cov0" title="0">if _, ok := d["children"]; ok </span><span class="cov0" title="0">{
                children := d["children"].([]interface{})
                for _, child := range children </span><span class="cov0" title="0">{
                        text += recursiveNoteTextParser(child.(map[string]interface{}))
                }</span>
        }
        <span class="cov0" title="0">return text</span>
}

func getNotesTextFromNoteJSON(jsonStr string) (string, error) <span class="cov0" title="0">{
        noteStr := ""

        var note map[string]interface{}

        err := json.Unmarshal([]byte(jsonStr), &amp;note)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">docRoot, ok := note["root"].(map[string]interface{})

        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("invalid note text, root node not present")
        }</span>

        // recursively prase children nodes
        <span class="cov0" title="0">noteStr = recursiveNoteTextParser(docRoot)

        if len(noteStr) == 0 </span><span class="cov0" title="0">{
                return "", errors.New("invalid note text nodes ")
        }</span>

        <span class="cov0" title="0">return noteStr, nil</span>
}

func extractSearchTerms(title, note, domainName string) []string <span class="cov0" title="0">{
        allText := strings.ToLower(title + " " + note)

        words := strings.Fields(allText)

        stemmedTerms := make(map[string]bool)

        for _, word := range words </span><span class="cov0" title="0">{

                if len(word) &lt; 3 || isCommonWord(word) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">stemmed, _ := snowball.Stem(word, "english", true)

                stemmedTerms[stemmed] = true</span>
        }

        <span class="cov0" title="0">searchTerms := []string{}

        for term := range stemmedTerms </span><span class="cov0" title="0">{
                searchTerms = append(searchTerms, term)
        }</span>

        // add domain name as search terms
        <span class="cov0" title="0">if domainName != "" </span><span class="cov0" title="0">{

                // full domain as search term
                searchTerms = append(searchTerms, domainName)

                domainTerms := strings.Split(domainName, ".")

                // domain without extension as search term

                if len(domainTerms) &lt; 3 </span><span class="cov0" title="0">{
                        // no subdomain
                        searchTerms = append(searchTerms, domainTerms[0])
                }</span> else<span class="cov0" title="0"> {
                        withOutExt := domainTerms[:len(domainTerms)-1]
                        domainName = strings.Join(withOutExt, ".")

                        searchTerms = append(searchTerms, domainName)
                }</span>
        }

        <span class="cov0" title="0">return searchTerms</span>
}

func isCommonWord(word string) bool <span class="cov0" title="0">{
        commonWords := map[string]bool{
                "the": true, "a": true, "an": true, "and": true, "or": true, "but": true,
                "in": true, "on": true, "at": true, "to": true, "for": true, "of": true,
                "with": true, "by": true, "from": true, "up": true, "about": true, "into": true,
                "over": true, "after": true, "is": true, "are": true, "was": true, "were": true,
        }

        return commonWords[word]
}</span>

func getNoteIdsBySearchTerms(userId string, searchTerms []string, limit int, r noteRepository) ([]string, error) <span class="cov0" title="0">{

        noteIdSets := []map[string]bool{}

        for _, term := range searchTerms </span><span class="cov0" title="0">{
                stemmed, _ := snowball.Stem(term, "english", true)

                logger.Dev("stemmed term: %v", stemmed)

                noteIds, err := r.noteIdsBySearchTerm(userId, stemmed, limit)

                if err != nil </span><span class="cov0" title="0">{
                        if err.Error() == errMsg.notesSearchEmpty </span><span class="cov0" title="0">{
                                continue</span>
                        } else<span class="cov0" title="0"> {
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">noteIdSet := make(map[string]bool)
                for _, id := range noteIds </span><span class="cov0" title="0">{
                        noteIdSet[id] = true
                }</span>

                <span class="cov0" title="0">noteIdSets = append(noteIdSets, noteIdSet)</span>
        }

        <span class="cov0" title="0">logger.Dev("num noteIdSets: %v", len(noteIdSets))

        if len(noteIdSets) &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New(errMsg.notesSearchEmpty)
        }</span>

        // Find intersection of note IDs
        <span class="cov0" title="0">intersection := noteIdSets[0]

        if len(noteIdSets) &gt; 1 </span><span class="cov0" title="0">{
                for _, set := range noteIdSets[1:] </span><span class="cov0" title="0">{
                        for id := range intersection </span><span class="cov0" title="0">{
                                if !set[id] </span><span class="cov0" title="0">{
                                        delete(intersection, id)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">notesIdsMatched := make([]string, 0, len(intersection))

        for id := range intersection </span><span class="cov0" title="0">{
                notesIdsMatched = append(notesIdsMatched, id)
        }</span>

        <span class="cov0" title="0">logger.Dev("notesIdsMatched: %v", notesIdsMatched)

        if len(notesIdsMatched) &gt; limit </span><span class="cov0" title="0">{
                notesIdsMatched = notesIdsMatched[:limit]
        }</span>

        <span class="cov0" title="0">return notesIdsMatched, nil</span>
}

// middleware to get userId from jwt token present in req cookies
func newUserIdMiddleware() http_api.Handler <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{

                // get userId from jwt token

                userId := r.Header.Get("UserId")

                if userId == "" </span><span class="cov0" title="0">{
                        http.Redirect(w, r, "/logout", http.StatusTemporaryRedirect)
                        return
                }</span>

                <span class="cov0" title="0">r.SetPathValue("userId", userId)</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package notes

import "github.com/go-playground/validator/v10"

type Note struct {
        Id          string `json:"id" validate:"required"`
        Title       string `json:"title" validate:"required"`
        Text        string `json:"text,omitempty" validate:"required"`
        SpaceId     string `json:"spaceId,omitempty"`
        Domain      string `json:"domain,omitempty"`
        RemainderAt int64  `json:"remainderAt,omitempty"`
        UpdatedAt   int64  `json:"updatedAt,omitempty"`
}

func (n *Note) validate() error <span class="cov0" title="0">{
        validate := validator.New(validator.WithRequiredStructEnabled())
        err := validate.Struct(n)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

var errMsg = struct {
        noteCreate       string
        noteUpdate       string
        noteGet          string
        noteId           string
        notesGet         string
        notesGetEmpty    string
        noteDelete       string
        notesSearch      string
        notesSearchEmpty string
}{
        noteCreate:       "error creating note",
        noteUpdate:       "error updating note",
        noteId:           "note id is required",
        noteGet:          "error getting note",
        notesGetEmpty:    "notes not found",
        notesGet:         "error getting notes",
        noteDelete:       "error deleting note",
        notesSearch:      "error searching notes",
        notesSearchEmpty: "no notes found",
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package notes

import (
        "context"
        "errors"
        "fmt"
        "reflect"
        "strings"
        "sync"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
        "github.com/manishMandal02/tabsflow-backend/pkg/db"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

type noteRepository interface {
        createNote(userId string, n *Note) error
        GetNote(userId string, noteId string) (*Note, error)
        getNotesByIds(userId string, noteIds *[]string) (*[]Note, error)
        getNotesByUser(userId string, lastNoteId int64) (*[]Note, error)
        updateNote(userId string, n *Note) error
        deleteNote(userId, noteId string) error
        // search
        indexSearchTerms(userId, noteId string, terms []string) error
        noteIdsBySearchTerm(userId string, query string, limit int) ([]string, error)
        deleteSearchTerms(userId, noteId string, terms []string) error
}

type noteRepo struct {
        db               *db.DDB
        searchIndexTable *db.DDB
}

func NewNoteRepository(db *db.DDB, searchIndexTable *db.DDB) noteRepository <span class="cov0" title="0">{
        return &amp;noteRepo{
                db:               db,
                searchIndexTable: searchIndexTable,
        }
}</span>

func (r noteRepo) createNote(userId string, n *Note) error <span class="cov0" title="0">{
        av, err := attributevalue.MarshalMap(n)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't marshal note: %v, \n[Error]: %v", n, err)
                return err
        }</span>

        <span class="cov0" title="0">av[db.PK_NAME] = &amp;types.AttributeValueMemberS{Value: userId}

        av[db.SK_NAME] = &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.Notes(n.Id)}

        _, err = r.db.Client.PutItem(context.TODO(), &amp;dynamodb.PutItemInput{
                TableName: &amp;r.db.TableName,
                Item:      av,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't create note for userId: %v, \n[Error]: %v", userId, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r noteRepo) updateNote(userId string, n *Note) error <span class="cov0" title="0">{

        key := map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{Value: userId},
                "SK": &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.Notes(n.Id)},
        }

        var update expression.UpdateBuilder
        // iterate over the fields of the struct
        v := reflect.ValueOf(n)

        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span> else<span class="cov0" title="0"> {
                logger.Error("unexpected type", errors.New(v.Kind().String()))
                return errors.ErrUnsupported
        }</span>

        <span class="cov0" title="0">t := v.Type()
        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                field := t.Field(i)
                fieldValue := v.Field(i)

                if fieldValue.IsZero() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">update = update.Set(expression.Name(field.Name), expression.Value(v.Field(i).Interface()))</span>
        }

        <span class="cov0" title="0">expr, err := expression.NewBuilder().WithUpdate(update).Build()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = r.db.Client.UpdateItem(context.TODO(), &amp;dynamodb.UpdateItemInput{
                TableName:                 &amp;r.db.TableName,
                Key:                       key,
                ExpressionAttributeNames:  expr.Names(),
                ExpressionAttributeValues: expr.Values(),
                UpdateExpression:          expr.Update(),
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't update note for userId: %v. \n[Error]: %v", userId, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r noteRepo) deleteNote(userId string, noteId string) error <span class="cov0" title="0">{
        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: userId},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.Notes(noteId)},
        }

        _, err := r.db.Client.DeleteItem(context.TODO(), &amp;dynamodb.DeleteItemInput{
                TableName:    &amp;r.db.TableName,
                Key:          key,
                ReturnValues: types.ReturnValueAllOld,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't delete note for userId: %v. \n[Error]: %v", userId, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r noteRepo) GetNote(userId string, noteId string) (*Note, error) <span class="cov0" title="0">{

        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: userId},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.Notes(noteId)},
        }

        response, err := r.db.Client.GetItem(context.TODO(), &amp;dynamodb.GetItemInput{
                TableName: &amp;r.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get note for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(response.Item) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New(errMsg.notesGetEmpty)
        }</span>

        <span class="cov0" title="0">note := &amp;Note{}

        err = attributevalue.UnmarshalMap(response.Item, note)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal note for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return note, nil</span>
}

func (r noteRepo) getNotesByIds(userId string, noteIds *[]string) (*[]Note, error) <span class="cov0" title="0">{

        keys := []map[string]types.AttributeValue{}

        for _, noteId := range *noteIds </span><span class="cov0" title="0">{
                keys = append(keys, map[string]types.AttributeValue{
                        db.PK_NAME: &amp;types.AttributeValueMemberS{Value: userId},
                        db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.Notes(noteId)},
                })
        }</span>

        <span class="cov0" title="0">response, err := r.db.Client.BatchGetItem(context.TODO(), &amp;dynamodb.BatchGetItemInput{
                RequestItems: map[string]types.KeysAndAttributes{
                        r.db.TableName: {
                                Keys: keys,
                                AttributesToGet: []string{
                                        db.PK_NAME,
                                        db.SK_NAME,
                                        "Title",
                                        "Domain",
                                        "UpdatedAt",
                                        "SpaceId",
                                        "Id",
                                        "RemainderAt",
                                },
                        },
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get notes for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(response.Responses[r.db.TableName]) &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New(errMsg.notesGetEmpty)
        }</span>

        <span class="cov0" title="0">notes := []Note{}

        err = attributevalue.UnmarshalListOfMaps(response.Responses[r.db.TableName], &amp;notes)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal notes for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;notes, nil</span>

}

func (r noteRepo) getNotesByUser(userId string, lastNoteId int64) (*[]Note, error) <span class="cov0" title="0">{

        key := expression.KeyAnd(expression.Key(db.PK_NAME).Equal(expression.Value(userId)), expression.Key(db.SK_NAME).BeginsWith(db.SORT_KEY.Notes("")))

        expr, err := expression.NewBuilder().WithKeyCondition(key).Build()

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't build getNotesByUser() expression for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var startKey map[string]types.AttributeValue

        if lastNoteId != 0 </span><span class="cov0" title="0">{
                startKey = map[string]types.AttributeValue{
                        db.PK_NAME: &amp;types.AttributeValueMemberS{Value: userId},
                        db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.Notes(fmt.Sprintf("%v", lastNoteId))},
                }
        }</span>

        <span class="cov0" title="0">response, err := r.db.Client.Query(context.TODO(), &amp;dynamodb.QueryInput{
                TableName:                 &amp;r.db.TableName,
                ExpressionAttributeNames:  expr.Names(),
                ExpressionAttributeValues: expr.Values(),
                KeyConditionExpression:    expr.KeyCondition(),
                Limit:                     aws.Int32(10),
                ExclusiveStartKey:         startKey,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get notes for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(response.Items) &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New(errMsg.notesGetEmpty)
        }</span>

        <span class="cov0" title="0">notes := []Note{}

        err = attributevalue.UnmarshalListOfMaps(response.Items, &amp;notes)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal notes for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;notes, nil</span>
}

// search index table
func (r noteRepo) indexSearchTerms(userId, noteId string, terms []string) error <span class="cov0" title="0">{

        // channel to collect errors from goroutines
        errChan := make(chan error, len(terms)/db.DDB_MAX_BATCH_SIZE+1)

        var wg sync.WaitGroup

        // context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        reqs := []types.WriteRequest{}

        for _, term := range terms </span><span class="cov0" title="0">{
                reqs = append(
                        reqs,
                        types.WriteRequest{
                                PutRequest: &amp;types.PutRequest{
                                        Item: map[string]types.AttributeValue{
                                                db.PK_NAME: &amp;types.AttributeValueMemberS{
                                                        Value: createSearchTermPK(userId, term),
                                                },
                                                db.SK_NAME: &amp;types.AttributeValueMemberS{
                                                        Value: db.SORT_KEY_SEARCH_INDEX.Note(noteId),
                                                },
                                        },
                                },
                        },
                )
        }</span>

        <span class="cov0" title="0">r.db.BatchWriter(ctx, &amp;wg, errChan, reqs)

        // Wait for all goroutines to complete
        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(errChan)
        }</span>()

        // Collect errors
        <span class="cov0" title="0">var errs []error
        for err := range errChan </span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span>

        // Return combined errors if any
        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("indexSearchTerms errors: %v", errs)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r noteRepo) noteIdsBySearchTerm(userId string, query string, limit int) ([]string, error) <span class="cov0" title="0">{

        key := expression.KeyAnd(expression.Key(db.PK_NAME).Equal(expression.Value(createSearchTermPK(userId, query))), expression.Key(db.SK_NAME).BeginsWith(db.SORT_KEY_SEARCH_INDEX.Note("")))

        expr, err := expression.NewBuilder().WithKeyCondition(key).Build()

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't build searchNotes expression for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">response, err := r.searchIndexTable.Client.Query(context.TODO(), &amp;dynamodb.QueryInput{
                TableName:                 &amp;r.searchIndexTable.TableName,
                ExpressionAttributeNames:  expr.Names(),
                ExpressionAttributeValues: expr.Values(),
                KeyConditionExpression:    expr.KeyCondition(),
                Limit:                     aws.Int32(int32(limit)),
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't search notes for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(response.Items) &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New(errMsg.notesSearchEmpty)
        }</span>

        <span class="cov0" title="0">noteIdsSK := []struct {
                Id string `json:"id" dynamodbav:"SK"`
        }{}

        err = attributevalue.UnmarshalListOfMaps(response.Items, &amp;noteIdsSK)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal notes for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">noteIds := []string{}

        for _, note := range noteIdsSK </span><span class="cov0" title="0">{
                id := strings.Split(note.Id, "#")[1]
                noteIds = append(noteIds, id)
        }</span>

        <span class="cov0" title="0">return noteIds, nil</span>
}

func (r noteRepo) deleteSearchTerms(userId, noteId string, terms []string) error <span class="cov0" title="0">{

        // channel to collect errors from goroutines
        errChan := make(chan error, len(terms)/db.DDB_MAX_BATCH_SIZE+1)

        var wg sync.WaitGroup

        // context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        reqs := []types.WriteRequest{}

        for _, term := range terms </span><span class="cov0" title="0">{
                reqs = append(reqs, types.WriteRequest{
                        DeleteRequest: &amp;types.DeleteRequest{
                                Key: map[string]types.AttributeValue{
                                        db.PK_NAME: &amp;types.AttributeValueMemberS{Value: createSearchTermPK(userId, term)},
                                        db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY_SEARCH_INDEX.Note(noteId)},
                                },
                        },
                })
        }</span>

        <span class="cov0" title="0">r.db.BatchWriter(ctx, &amp;wg, errChan, reqs)

        // Wait for all goroutines to complete
        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(errChan)
        }</span>()

        // Collect errors
        <span class="cov0" title="0">var errs []error
        for err := range errChan </span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span>

        // Return combined errors if any
        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("delete search index errors: %v", errs)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// * helpers
func createSearchTermPK(userId string, term string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s#%s", userId, term)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package notes

import (
        "github.com/manishMandal02/tabsflow-backend/pkg/db"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
)

func Router() http_api.IRouter <span class="cov0" title="0">{
        mainDB := db.New()
        searchIndexTable := db.NewSearchIndexTable()
        nr := NewNoteRepository(mainDB, searchIndexTable)
        nh := newNoteHandler(nr)

        // middleware to get userId from jwt token
        userIdMiddleware := newUserIdMiddleware()

        notesRouter := http_api.NewRouter("/notes")

        notesRouter.Use(userIdMiddleware)

        notesRouter.POST("/", nh.create)
        // query: lastNoteId={lastNoteId}
        notesRouter.GET("/my", nh.getAllByUser)
        // query: query={searchTerm}, limit={maxLimit}
        notesRouter.GET("/search", nh.search)

        notesRouter.GET("/:noteId", nh.get)

        notesRouter.PATCH("/", nh.update)

        notesRouter.DELETE("/:noteId", nh.delete)

        // serve API routes
        return notesRouter
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package notifications

import (
        "encoding/json"
        "net/http"

        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

type notificationHandler struct {
        r notificationRepository
}

func newHandler(r notificationRepository) *notificationHandler <span class="cov0" title="0">{
        return &amp;notificationHandler{
                r: r,
        }
}</span>

func (h *notificationHandler) get(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")
        notificationId := r.PathValue("id")

        if notificationId == "" </span><span class="cov0" title="0">{
                http.Error(w, errMsg.notificationGet, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">n, err := h.r.get(userId, notificationId)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == errMsg.notificationsEmpty </span><span class="cov0" title="0">{
                        http_api.SuccessResData(w, []notification{})
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, errMsg.notificationGet, http.StatusBadGateway)
                return</span>
        }

        <span class="cov0" title="0">http_api.SuccessResData(w, n)</span>
}

func (h *notificationHandler) getUserNotifications(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")

        notifications, err := h.r.getUserNotifications(userId)

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == errMsg.notificationsEmpty </span><span class="cov0" title="0">{
                        http_api.SuccessResData(w, []notification{})
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, errMsg.notificationGet, http.StatusBadGateway)
                return</span>
        }

        <span class="cov0" title="0">http_api.SuccessResData(w, notifications)</span>
}

func (h *notificationHandler) subscribe(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")

        var subscription PushSubscription

        err := json.NewDecoder(r.Body).Decode(&amp;subscription)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error decoding notification subscription for user_id: %v. \n[Error]: %v", userId, err)
                http.Error(w, errMsg.notificationsSubscribe, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = subscription.validate()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error validating notification subscription for user_id: %v. \n[Error]: %v", userId, err)
                http.Error(w, errMsg.notificationsSubscribe, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.r.subscribe(userId, &amp;subscription)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, errMsg.notificationsSubscribe, http.StatusBadGateway)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResMsg(w, "Subscribed to  notifications")</span>
}

func (h *notificationHandler) getNotificationSubscription(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")

        subscription, err := h.r.getNotificationSubscription(userId)

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == errMsg.notificationsSubscribeEmpty </span><span class="cov0" title="0">{
                        http_api.SuccessResData(w, PushSubscription{})
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, errMsg.notificationsSubscribeEmpty, http.StatusBadGateway)
                return</span>
        }

        <span class="cov0" title="0">http_api.SuccessResData(w, subscription)</span>

}

func (h *notificationHandler) unsubscribe(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")

        err := h.r.deleteNotificationSubscription(userId)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, errMsg.notificationsUnsubscribe, http.StatusBadGateway)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResMsg(w, "Unsubscribed from notifications")</span>

}

func (h *notificationHandler) delete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        userId := r.PathValue("userId")
        notificationId := r.PathValue("id")

        if notificationId == "" </span><span class="cov0" title="0">{
                http.Error(w, errMsg.notificationDelete, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := h.r.delete(userId, notificationId)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error deleting notification", err)
                http.Error(w, errMsg.notificationDelete, http.StatusBadGateway)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResMsg(w, "notification deleted successfully")</span>
}

// func (h *notificationHandler) create(w http.ResponseWriter, r *http.Request) {
//         userId := r.PathValue("userId")
//         n := notification{}
//         err := json.NewDecoder(r.Body).Decode(&amp;n)
//         if err != nil {
//                 logger.Error("error decoding notification", err)
//                 http.Error(w, errMsg.notificationCreate, http.StatusBadRequest)
//                 return
//         }
//         err = h.r.createNotification(userId, &amp;n)
//         if err != nil {
//                 logger.Error("error creating notification", err)
//                 http.Error(w, errMsg.notificationCreate, http.StatusBadGateway)
//                 return
//         }
//         http_api.SuccessResMsg(w, "notification created successfully")
// }

//* helpers

// middleware to get userId from jwt token present in req cookies
func newUserIdMiddleware() http_api.Handler <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{

                // get userId from jwt token

                userId := r.Header.Get("UserId")

                if userId == "" </span><span class="cov0" title="0">{
                        http.Redirect(w, r, "/logout", http.StatusTemporaryRedirect)
                        return
                }</span>

                <span class="cov0" title="0">r.SetPathValue("userId", userId)</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package notifications

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "strconv"
        "time"

        web_push "github.com/SherClockHolmes/webpush-go"
        lambda_events "github.com/aws/aws-lambda-go/events"
        "github.com/manishMandal02/tabsflow-backend/config"
        "github.com/manishMandal02/tabsflow-backend/internal/notes"
        "github.com/manishMandal02/tabsflow-backend/internal/spaces"
        "github.com/manishMandal02/tabsflow-backend/pkg/db"
        "github.com/manishMandal02/tabsflow-backend/pkg/events"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

func EventsHandler(_ context.Context, event lambda_events.SQSEvent) (interface{}, error) <span class="cov0" title="0">{
        if len(event.Records) &lt; 1 </span><span class="cov0" title="0">{
                errMsg := "no events to process"
                logger.Errorf("%v", errMsg)

                return nil, errors.New(errMsg)
        }</span>

        //  process batch of events
        <span class="cov0" title="0">for _, record := range event.Records </span><span class="cov0" title="0">{

                logger.Info("processing record: %v", record.Body)

                eventType := ""

                if _, ok := record.MessageAttributes["event_type"]; ok </span><span class="cov0" title="0">{
                        eventType = *record.MessageAttributes["event_type"].StringValue
                }</span> else<span class="cov0" title="0"> {

                        var e events.Event[any]

                        err := e.FromJSON(record.Body)

                        eventType = string(e.EventType)

                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("error un_marshalling event from json: %v", err)
                        }</span>

                }

                <span class="cov0" title="0">err := processEvent(eventType, record.Body)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error processing event: %v", err)
                        continue</span>
                }

                // remove message from sqs
                <span class="cov0" title="0">q := events.NewNotificationQueue()

                err = q.DeleteMessage(record.ReceiptHandle)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

        }

        <span class="cov0" title="0">return nil, nil</span>
}

func processEvent(eventType string, body string) error <span class="cov0" title="0">{
        switch events.EventType(eventType) </span>{
        case events.EventTypeScheduleNoteRemainder:<span class="cov0" title="0">

                ev, err := events.NewFromJSON[events.ScheduleNoteRemainderPayload](body)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error un_marshalling event: %v", err)
                        return err
                }</span>

                <span class="cov0" title="0">return scheduleNoteRemainder(ev.Payload)</span>

        case events.EventTypeScheduleSnoozedTab:<span class="cov0" title="0">

                ev, err := events.NewFromJSON[events.ScheduleSnoozedTabPayload](body)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error un_marshalling event: %v", err)
                        return err
                }</span>

                <span class="cov0" title="0">return scheduleSnoozedTab(ev.Payload)</span>

        case events.EventTypeTriggerNoteRemainder:<span class="cov0" title="0">

                ev, err := events.NewFromJSON[events.ScheduleNoteRemainderPayload](body)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error un_marshalling event: %v", err)
                        return err
                }</span>

                <span class="cov0" title="0">return triggerNoteRemainder(ev.Payload)</span>

        case events.EventTypeTriggerSnoozedTab:<span class="cov0" title="0">
                ev, err := events.NewFromJSON[events.ScheduleSnoozedTabPayload](body)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error un_marshalling event: %v", err)
                        return err
                }</span>

                <span class="cov0" title="0">return triggerSnoozedTab(ev.Payload)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// set a schedule to trigger a note remainder notification
func scheduleNoteRemainder(p *events.ScheduleNoteRemainderPayload) error <span class="cov0" title="0">{
        var err error

        scheduler := events.NewScheduler()

        sId := fmt.Sprintf("note_%v", p.NoteId)

        switch p.SubEvent </span>{
        case events.SubEventCreate:<span class="cov0" title="0">
                triggerEvent := events.New(events.EventTypeTriggerNoteRemainder, &amp;events.ScheduleNoteRemainderPayload{
                        UserId: p.UserId,
                        NoteId: p.NoteId,
                })

                evStr := triggerEvent.ToJSON()

                t := time.Unix(p.TriggerAt, 0).UTC().Format(config.DATE_TIME_FORMAT)

                err = scheduler.CreateSchedule(sId, t, &amp;evStr)</span>
        case events.SubEventUpdate:<span class="cov0" title="0">
                t := time.Unix(p.TriggerAt, 0).UTC().Format(config.DATE_TIME_FORMAT)
                err = scheduler.UpdateSchedule(sId, t)</span>
        case events.SubEventDelete:<span class="cov0" title="0">
                err = scheduler.DeleteSchedule(sId)</span>
        }

        <span class="cov0" title="0">return err</span>
}

// set a schedule to trigger a snoozed tab notification
func scheduleSnoozedTab(p *events.ScheduleSnoozedTabPayload) error <span class="cov0" title="0">{

        scheduler := events.NewScheduler()
        var err error

        sId := fmt.Sprintf("snoozedTab_%v", p.SnoozedTabId)

        switch p.SubEvent </span>{
        case events.SubEventCreate:<span class="cov0" title="0">
                triggerEvent := events.New(events.EventTypeTriggerSnoozedTab, &amp;events.ScheduleSnoozedTabPayload{
                        UserId:       p.UserId,
                        SpaceId:      p.SpaceId,
                        SnoozedTabId: p.SnoozedTabId,
                })

                evStr := triggerEvent.ToJSON()

                t := time.Unix(p.TriggerAt, 0).UTC().Format(config.DATE_TIME_FORMAT)

                err = scheduler.CreateSchedule(sId, t, &amp;evStr)</span>
        case events.SubEventUpdate:<span class="cov0" title="0">
                t := time.Unix(p.TriggerAt, 0).UTC().Format(config.DATE_TIME_FORMAT)

                err = scheduler.UpdateSchedule(sId, t)</span>
        case events.SubEventDelete:<span class="cov0" title="0">
                err = scheduler.DeleteSchedule(sId)</span>
        }

        <span class="cov0" title="0">return err</span>
}

// send note notification to user
func triggerNoteRemainder(p *events.ScheduleNoteRemainderPayload) error <span class="cov0" title="0">{
        db := db.New()
        r := newRepository(db)
        s, err := r.getNotificationSubscription(p.UserId)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">note, err := getNote(db, p.UserId, p.NoteId)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // create notification
        <span class="cov0" title="0">notification := notification{
                Id:        strconv.FormatInt(time.Now().UTC().Unix(), 10),
                Type:      notificationTypeNoteRemainder,
                IsRead:    false,
                Timestamp: time.Now().UTC().Unix(),
                Note: &amp;noteRemainderNotification{
                        Id:     note.Id,
                        Title:  note.Title,
                        Domain: note.Domain,
                },
        }

        err = r.create(p.UserId, &amp;notification)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">n, err := json.Marshal(note)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error marshalling note", err)
                return err
        }</span>

        <span class="cov0" title="0">err = sendWebPushNotification(p.UserId, s, n)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error sending web push notification", err)
                return err

        }</span>

        //TODO: remove remainder at

        <span class="cov0" title="0">return nil</span>

}

// send snoozed tab notification to user
func triggerSnoozedTab(p *events.ScheduleSnoozedTabPayload) error <span class="cov0" title="0">{
        db := db.New()
        r := newRepository(db)
        s, err := r.getNotificationSubscription(p.UserId)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">snoozedTab, err := getSnoozedTab(db, p.UserId, p.SpaceId, p.SnoozedTabId)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // create notification
        <span class="cov0" title="0">notification := notification{
                Id:        strconv.FormatInt(time.Now().UTC().Unix(), 10),
                Type:      notificationTypeUnSnoozedType,
                IsRead:    false,
                Timestamp: time.Now().UTC().Unix(),
                SnoozedTab: &amp;snoozedTabNotification{
                        Id:    p.SnoozedTabId,
                        Title: snoozedTab.Title,
                        Icon:  snoozedTab.Icon,
                },
        }

        err = r.create(p.UserId, &amp;notification)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">t, err := json.Marshal(snoozedTab)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error marshalling snoozedTab", err)
                return err
        }</span>

        <span class="cov0" title="0">err = sendWebPushNotification(p.UserId, s, t)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error sending web push notification", err)
                return err

        }</span>

        // TODO: delete snoozed tab

        <span class="cov0" title="0">return nil</span>

}

// * helpers
func sendWebPushNotification(userId string, s *PushSubscription, body []byte) error <span class="cov0" title="0">{

        ws := &amp;web_push.Subscription{
                Endpoint: s.Endpoint,
                Keys: web_push.Keys{
                        Auth:   s.AuthKey,
                        P256dh: s.P256dhKey,
                },
        }
        o := &amp;web_push.Options{
                TTL:             300,
                Subscriber:      userId,
                VAPIDPrivateKey: config.VAPID_PRIVATE_KEY,
                VAPIDPublicKey:  config.VAPID_PUBLIC_KEY,
        }

        var bEnc = make([]byte, base64.StdEncoding.EncodedLen(len(body)))

        base64.StdEncoding.Encode(bEnc, body)

        _, err := web_push.SendNotification(bEnc, ws, o)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func getNote(db *db.DDB, userId, noteId string) (*notes.Note, error) <span class="cov0" title="0">{

        r := notes.NewNoteRepository(db, nil)

        note, err := r.GetNote(userId, noteId)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return note, nil</span>
}

func getSnoozedTab(db *db.DDB, userId, spaceId, snoozedTabId string) (*spaces.SnoozedTab, error) <span class="cov0" title="0">{

        r := spaces.NewSpaceRepository(db)

        snoozedTabIdInt, err := strconv.ParseInt(snoozedTabId, 10, 64)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error parsing snoozed tab id to int", err)
                return nil, err

        }</span>

        <span class="cov0" title="0">snoozedTab, err := r.GetSnoozedTab(userId, spaceId, snoozedTabIdInt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return snoozedTab, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package notifications

import "github.com/go-playground/validator/v10"

type NotificationType string

const (
        notificationTypeAccount       NotificationType = "account"
        notificationTypeNoteRemainder NotificationType = "note_remainder"
        notificationTypeUnSnoozedType NotificationType = "un_snoozed_tab"
)

type snoozedTabNotification struct {
        Id    string `json:"id"`
        Title string `json:"title"`
        Icon  string `json:"icon"`
}

type noteRemainderNotification struct {
        Id     string `json:"id"`
        Title  string `json:"title"`
        Domain string `json:"domain"`
}

type notification struct {
        Id         string                     `json:"id"`
        Type       NotificationType           `json:"type"`
        IsRead     bool                       `json:"isRead"`
        Timestamp  int64                      `json:"timestamp"`
        Title      string                     `json:"title,omitempty"`
        Message    string                     `json:"message,omitempty"`
        Note       *noteRemainderNotification `json:"note,omitempty"`
        SnoozedTab *snoozedTabNotification    `json:"snoozedTab,omitempty"`
}

var errMsg = struct {
        notificationGet              string
        notificationDelete           string
        notificationsEmpty           string
        notificationsSubscribe       string
        notificationsSubscribeEmpty  string
        notificationsUnsubscribe     string
        notificationsSubscriptionGet string
}{
        notificationDelete:           "error deleting notification",
        notificationGet:              "error getting notifications",
        notificationsEmpty:           "no notifications found",
        notificationsSubscribe:       "error subscribing to notifications",
        notificationsUnsubscribe:     "error unsubscribing from notifications",
        notificationsSubscribeEmpty:  "Not subscribed to notifications",
        notificationsSubscriptionGet: "error getting notification subscription",
}

type PushSubscription struct {
        Endpoint  string `json:"endpoint,omitempty" validate:"required"`
        AuthKey   string `json:"authKey,omitempty" validate:"required"`
        P256dhKey string `json:"p256dhKey,omitempty" validate:"required"`
}

func (p PushSubscription) validate() error <span class="cov0" title="0">{
        validate := validator.New(validator.WithRequiredStructEnabled())

        err := validate.Struct(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package notifications

import (
        "context"
        "errors"

        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
        "github.com/manishMandal02/tabsflow-backend/pkg/db"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

type notificationRepository interface {
        create(userId string, notification *notification) error
        get(userId, notificationId string) (notification, error)
        delete(userId, notificationId string) error
        subscribe(userId string, s *PushSubscription) error
        getNotificationSubscription(userId string) (*PushSubscription, error)
        getUserNotifications(userId string) ([]notification, error)
        deleteNotificationSubscription(userId string) error
}

type noteRepo struct {
        db *db.DDB
}

func newRepository(db *db.DDB) notificationRepository <span class="cov0" title="0">{
        return &amp;noteRepo{
                db: db,
        }
}</span>

func (nr *noteRepo) create(userId string, notification *notification) error <span class="cov0" title="0">{

        item, err := attributevalue.MarshalMap(notification)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error marshalling notification", err)
                return err
        }</span>

        <span class="cov0" title="0">item[db.PK_NAME] = &amp;types.AttributeValueMemberS{
                Value: userId,
        }
        item[db.SK_NAME] = &amp;types.AttributeValueMemberS{
                Value: db.SORT_KEY.Notifications(notification.Id),
        }

        _, err = nr.db.Client.PutItem(context.TODO(), &amp;dynamodb.PutItemInput{
                TableName: &amp;nr.db.TableName,
                Item:      item,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error putting notification to dynamodb", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (nr *noteRepo) get(userId, notificationId string) (notification, error) <span class="cov0" title="0">{

        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{
                        Value: userId,
                },
                db.SK_NAME: &amp;types.AttributeValueMemberS{
                        Value: db.SORT_KEY.Notifications(notificationId),
                },
        }

        result, err := nr.db.Client.GetItem(context.TODO(), &amp;dynamodb.GetItemInput{
                TableName: &amp;nr.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error getting notification from dynamodb", err)
                return notification{}, err
        }</span>

        <span class="cov0" title="0">if result.Item == nil </span><span class="cov0" title="0">{
                return notification{}, errors.New(errMsg.notificationsEmpty)
        }</span>

        <span class="cov0" title="0">var n notification
        err = attributevalue.UnmarshalMap(result.Item, &amp;n)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error unmarshalling notification", err)
                return notification{}, err
        }</span>

        <span class="cov0" title="0">return n, nil</span>
}

func (nr *noteRepo) getUserNotifications(userId string) ([]notification, error) <span class="cov0" title="0">{

        key := expression.KeyAnd(expression.Key(db.PK_NAME).Equal(expression.Value(userId)), expression.Key(db.SK_NAME).BeginsWith(db.SORT_KEY.Notifications("")))
        expr, err := expression.NewBuilder().WithKeyCondition(key).Build()

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error building expression", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">result, err := nr.db.Client.Query(context.TODO(), &amp;dynamodb.QueryInput{
                TableName:                 &amp;nr.db.TableName,
                KeyConditionExpression:    expr.KeyCondition(),
                ExpressionAttributeNames:  expr.Names(),
                ExpressionAttributeValues: expr.Values(),
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error querying dynamodb", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if result.Count &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New(errMsg.notificationsEmpty)
        }</span>

        <span class="cov0" title="0">var notifications []notification

        err = attributevalue.UnmarshalListOfMaps(result.Items, &amp;notifications)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error unmarshalling notifications", err)
                return notifications, err
        }</span>

        <span class="cov0" title="0">return notifications, nil</span>

}

func (nr *noteRepo) delete(userId, notificationId string) error <span class="cov0" title="0">{

        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{
                        Value: userId,
                },
                db.SK_NAME: &amp;types.AttributeValueMemberS{
                        Value: db.SORT_KEY.Notifications(notificationId),
                },
        }

        _, err := nr.db.Client.DeleteItem(context.TODO(), &amp;dynamodb.DeleteItemInput{
                TableName: &amp;nr.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error deleting notification", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// notification subscription
func (nr *noteRepo) subscribe(userId string, s *PushSubscription) error <span class="cov0" title="0">{
        item, err := attributevalue.MarshalMap(s)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error marshalling notification", err)
                return err
        }</span>

        <span class="cov0" title="0">item[db.PK_NAME] = &amp;types.AttributeValueMemberS{
                Value: userId,
        }

        item[db.SK_NAME] = &amp;types.AttributeValueMemberS{
                Value: db.SORT_KEY.NotificationSubscription,
        }

        _, err = nr.db.Client.PutItem(context.TODO(), &amp;dynamodb.PutItemInput{
                TableName: &amp;nr.db.TableName,
                Item:      item,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error putting notification subscription to db", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (nr *noteRepo) getNotificationSubscription(userId string) (*PushSubscription, error) <span class="cov0" title="0">{

        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{
                        Value: userId,
                },
                db.SK_NAME: &amp;types.AttributeValueMemberS{
                        Value: db.SORT_KEY.NotificationSubscription,
                },
        }

        result, err := nr.db.Client.GetItem(context.TODO(), &amp;dynamodb.GetItemInput{
                TableName: &amp;nr.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error getting notification subscription from dynamodb", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if result.Item == nil </span><span class="cov0" title="0">{
                return nil, errors.New(errMsg.notificationsSubscribeEmpty)
        }</span>

        <span class="cov0" title="0">var s PushSubscription

        err = attributevalue.UnmarshalMap(result.Item, &amp;s)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error un_marshalling notification subscription", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;s, nil</span>

}

func (nr *noteRepo) deleteNotificationSubscription(userId string) error <span class="cov0" title="0">{

        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{
                        Value: userId,
                },
                db.SK_NAME: &amp;types.AttributeValueMemberS{
                        Value: db.SORT_KEY.NotificationSubscription,
                },
        }

        _, err := nr.db.Client.DeleteItem(context.TODO(), &amp;dynamodb.DeleteItemInput{
                TableName: &amp;nr.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error deleting notification subscription", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package notifications

import (
        "github.com/manishMandal02/tabsflow-backend/pkg/db"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
)

func Router() http_api.IRouter <span class="cov0" title="0">{
        db := db.New()
        nr := newRepository(db)
        h := newHandler(nr)

        // middleware to get userId from jwt token
        userIdMiddleware := newUserIdMiddleware()

        notificationsRouter := http_api.NewRouter("/notifications")

        notificationsRouter.Use(userIdMiddleware)

        // notifications subscription
        notificationsRouter.GET("/subscription", h.getNotificationSubscription)
        notificationsRouter.POST("/subscription", h.subscribe)
        notificationsRouter.DELETE("/subscription", h.unsubscribe)

        notificationsRouter.GET("/my", h.getUserNotifications)
        notificationsRouter.GET("/:id", h.get)
        notificationsRouter.DELETE("/:id", h.delete)

        // serve API routes
        return notificationsRouter
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package spaces

import (
        "encoding/json"
        "net/http"
        "strconv"

        "github.com/manishMandal02/tabsflow-backend/pkg/events"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

type spaceHandler struct {
        sr spaceRepository
}

func newSpaceHandler(sr spaceRepository) *spaceHandler <span class="cov0" title="0">{
        return &amp;spaceHandler{
                sr: sr,
        }
}</span>

func (h *spaceHandler) get(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")
        spaceId := r.PathValue("id")

        if spaceId == "" </span><span class="cov0" title="0">{
                http.Error(w, errMsg.spaceId, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">space, err := h.sr.getSpaceById(userId, spaceId)

        if err != nil </span><span class="cov0" title="0">{

                if err.Error() == errMsg.spaceNotFound </span><span class="cov0" title="0">{
                        //  space not found
                        http.Error(w, errMsg.spaceNotFound, http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, errMsg.spaceGet, http.StatusBadGateway)
                return</span>
        }

        <span class="cov0" title="0">http_api.SuccessResData(w, space)</span>
}

func (h *spaceHandler) spacesByUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")

        if userId == "" </span><span class="cov0" title="0">{
                http.Error(w, errMsg.groupsSet, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">spaces, err := h.sr.getSpacesByUser(userId)

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == errMsg.spaceNotFound </span><span class="cov0" title="0">{
                        http_api.SuccessResData(w, []string{})

                        return
                }</span>
                <span class="cov0" title="0">logger.Error("error getting spaces", err)
                http.Error(w, errMsg.spaceGet, http.StatusBadGateway)
                return</span>
        }

        <span class="cov0" title="0">http_api.SuccessResData(w, spaces)</span>

}

func (h *spaceHandler) create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        userId := r.PathValue("userId")

        s := space{}

        err := json.NewDecoder(r.Body).Decode(&amp;s)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error un_marshalling body", err)
                http.Error(w, errMsg.spaceCreate, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = s.validate()

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error validating space", err)
                http.Error(w, errMsg.spaceCreate, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.sr.createSpace(userId, &amp;s)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error creating space", err)
                http.Error(w, errMsg.spaceCreate, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResMsg(w, "space created successfully")</span>
}

func (h *spaceHandler) update(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        userId := r.PathValue("userId")

        s := space{}

        err := json.NewDecoder(r.Body).Decode(&amp;s)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error decoding space", err)
                http.Error(w, errMsg.spaceUpdate, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if s.Id == "" </span><span class="cov0" title="0">{
                http.Error(w, errMsg.spaceId, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">_, err = h.sr.getSpaceById(userId, s.Id)

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == errMsg.spaceNotFound </span><span class="cov0" title="0">{
                        //  space not found
                        http.Error(w, errMsg.spaceNotFound, http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, errMsg.spaceUpdate, http.StatusBadGateway)
                return</span>
        }

        <span class="cov0" title="0">err = h.sr.updateSpace(userId, &amp;s)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error updating space", err)
                http.Error(w, errMsg.spaceUpdate, http.StatusBadGateway)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResMsg(w, "space updated successfully")</span>
}

func (h *spaceHandler) delete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        spaceId := r.PathValue("spaceId")
        userId := r.PathValue("userId")

        if spaceId == "" </span><span class="cov0" title="0">{
                http.Error(w, errMsg.spaceId, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := h.sr.deleteSpace(userId, spaceId)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error deleting space", err)
                http.Error(w, errMsg.spaceDelete, http.StatusBadGateway)
                return
        }</span>
        <span class="cov0" title="0">http_api.SuccessResMsg(w, "space deleted successfully")</span>
}

// tabs
func (h *spaceHandler) getTabsInSpace(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")
        spaceId := r.PathValue("spaceId")

        tabs, err := h.sr.getTabsForSpace(userId, spaceId)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error getting tabs for space", err)
                http.Error(w, errMsg.tabsGet, http.StatusBadGateway)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResData(w, tabs)</span>
}

func (h *spaceHandler) setTabsInSpace(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")
        spaceId := r.PathValue("spaceId")

        if spaceId == "" </span><span class="cov0" title="0">{
                http.Error(w, errMsg.spaceId, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">data := struct {
                Tabs []tab `json:"tabs"`
        }{}

        err := json.NewDecoder(r.Body).Decode(&amp;data)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error decoding tabs", err)
                http.Error(w, errMsg.tabsSet, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if len(data.Tabs) &lt; 1 </span><span class="cov0" title="0">{
                http.Error(w, errMsg.tabsSet, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.sr.setTabsForSpace(userId, spaceId, &amp;data.Tabs)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error setting tabs for space", err)
                http.Error(w, errMsg.tabsSet, http.StatusBadGateway)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResMsg(w, "tabs set successfully")</span>
}

// groups
func (h *spaceHandler) getGroupsInSpace(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")
        spaceId := r.PathValue("spaceId")

        if spaceId == "" </span><span class="cov0" title="0">{
                http.Error(w, errMsg.spaceId, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">groups, err := h.sr.getGroupsForSpace(userId, spaceId)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error getting groups for space", err)
                http.Error(w, errMsg.groupsGet, http.StatusBadGateway)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResData(w, groups)</span>
}

func (h *spaceHandler) setGroupsInSpace(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")
        spaceId := r.PathValue("spaceId")

        if spaceId == "" </span><span class="cov0" title="0">{
                http.Error(w, errMsg.spaceId, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">data := struct {
                Groups []group `json:"groups"`
        }{}

        err := json.NewDecoder(r.Body).Decode(&amp;data)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error decoding groups", err)
                http.Error(w, errMsg.groupsSet, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if len(data.Groups) &lt; 1 </span><span class="cov0" title="0">{
                http.Error(w, errMsg.groupsSet, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.sr.setGroupsForSpace(userId, spaceId, &amp;data.Groups)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error setting groups for space", err)
                http.Error(w, errMsg.groupsSet, http.StatusBadGateway)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResMsg(w, "groups set successfully")</span>

}

// snoozed tabs
func (h *spaceHandler) createSnoozedTab(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")
        spaceId := r.PathValue("spaceId")

        sT := SnoozedTab{}

        err := json.NewDecoder(r.Body).Decode(&amp;sT)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error decoding snoozed tab", err)
                http.Error(w, errMsg.snoozedTabsCreate, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.sr.addSnoozedTab(userId, spaceId, &amp;sT)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error snoozing tab", err)
                http.Error(w, errMsg.snoozedTabsCreate, http.StatusBadGateway)
                return
        }</span>

        // create a schedule for the tab, to un-snooze the tab
        <span class="cov0" title="0">event := events.New(events.EventTypeScheduleSnoozedTab, &amp;events.ScheduleSnoozedTabPayload{
                UserId:       userId,
                SpaceId:      spaceId,
                SnoozedTabId: strconv.FormatInt(sT.SnoozedAt, 10),
                SubEvent:     events.SubEventCreate,
                TriggerAt:    sT.SnoozedUntil,
        })

        err = events.NewNotificationQueue().AddMessage(event)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, errMsg.snoozedTabsCreate, http.StatusBadGateway)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResMsg(w, "tab snoozed successfully")</span>
}

func (h *spaceHandler) getSnoozedTab(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")
        spaceId := r.PathValue("spaceId")
        snoozedTabId := r.PathValue("id")

        if spaceId == "" || snoozedTabId == "" </span><span class="cov0" title="0">{
                http.Error(w, errMsg.spaceId, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">intId, err := strconv.ParseInt(snoozedTabId, 10, 64)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error parsing snoozedTabId to int", err)
                http.Error(w, errMsg.snoozedTabsGet, http.StatusBadGateway)
                return
        }</span>

        <span class="cov0" title="0">sT, err := h.sr.GetSnoozedTab(userId, spaceId, intId)

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == errMsg.snoozedTabsNotFound </span><span class="cov0" title="0">{
                        http.Error(w, errMsg.snoozedTabsNotFound, http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">logger.Error("error getting snoozed tab", err)
                http.Error(w, errMsg.snoozedTabsGet, http.StatusBadGateway)
                return</span>
        }

        <span class="cov0" title="0">http_api.SuccessResData(w, sT)</span>
}

func (h *spaceHandler) getSnoozedTabsBySpace(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")
        spaceId := r.PathValue("spaceId")

        if spaceId == "" </span><span class="cov0" title="0">{
                http.Error(w, errMsg.spaceId, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">lastKey := r.URL.Query().Get("lastSnoozedTabId")

        if lastKey == "" </span><span class="cov0" title="0">{
                lastKey = "0"
        }</span>

        <span class="cov0" title="0">lastSnoozedTabId, err := strconv.ParseInt(lastKey, 10, 64)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error parsing lastSnoozedTabId", err)
                http.Error(w, errMsg.snoozedTabsGet, http.StatusBadRequest)
                return
        }</span>

        // return all snoozed tabs for space
        <span class="cov0" title="0">sT, err := h.sr.geSnoozedTabsInSpace(userId, spaceId, lastSnoozedTabId)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error getting snoozed tabs for space", err)
                http.Error(w, errMsg.snoozedTabsGet, http.StatusBadGateway)
                return
        }</span>
        <span class="cov0" title="0">http_api.SuccessResData(w, sT)</span>
}

func (h spaceHandler) getSnoozedTabByUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")

        lastKey := r.URL.Query().Get("lastSnoozedTabId")

        if lastKey == "" </span><span class="cov0" title="0">{
                lastKey = "0"
        }</span>

        <span class="cov0" title="0">lastSnoozedTabId, err := strconv.ParseInt(lastKey, 10, 64)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error parsing lastSnoozedTabId", err)
                http.Error(w, errMsg.snoozedTabsGet, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">sT, err := h.sr.getAllSnoozedTabsByUser(userId, lastSnoozedTabId)

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == errMsg.snoozedTabsNotFound </span><span class="cov0" title="0">{
                        http_api.SuccessResData(w, []SnoozedTab{})

                        return
                }</span>
                <span class="cov0" title="0">logger.Error("error getting snoozed tabs for user", err)
                http.Error(w, errMsg.snoozedTabsGet, http.StatusBadGateway)
                return</span>
        }

        <span class="cov0" title="0">http_api.SuccessResData(w, sT)</span>
}

func (h *spaceHandler) deleteSnoozedTab(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.PathValue("userId")
        spaceId := r.PathValue("spaceId")
        snoozedAt := r.PathValue("id")

        if spaceId == "" || snoozedAt == "" </span><span class="cov0" title="0">{
                http.Error(w, errMsg.spaceId, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">snoozedAtInt, err := strconv.ParseInt(snoozedAt, 10, 64)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error parsing snoozedAt", err)
                http.Error(w, errMsg.snoozedTabsDelete, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.sr.deleteSnoozedTab(userId, spaceId, snoozedAtInt)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error deleting snoozed tab", err)
                http.Error(w, errMsg.snoozedTabsDelete, http.StatusBadGateway)
                return
        }</span>

        //  delete notification the schedule
        <span class="cov0" title="0">event := events.New(events.EventTypeScheduleSnoozedTab, &amp;events.ScheduleSnoozedTabPayload{
                SnoozedTabId: snoozedAt,
                SubEvent:     events.SubEventDelete,
        })

        err = events.NewNotificationQueue().AddMessage(event)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, errMsg.snoozedTabsCreate, http.StatusBadGateway)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResMsg(w, "snoozed tab deleted successfully")</span>
}

//* helpers

// middleware to get userId from jwt token present in req cookies
func newUserIdMiddleware() http_api.Handler <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{

                // get userId from jwt token
                userId := r.Header.Get("UserId")

                if userId == "" </span><span class="cov0" title="0">{
                        http.Redirect(w, r, "/logout", http.StatusTemporaryRedirect)
                        w.Header().Add("Error", "userId not found")
                        return
                }</span>

                <span class="cov0" title="0">r.SetPathValue("userId", userId)</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package spaces

import (
        "context"
        "errors"
        "fmt"
        "reflect"
        "strconv"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
        "github.com/manishMandal02/tabsflow-backend/pkg/db"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

type spaceRepository interface {
        createSpace(userId string, s *space) error
        getSpaceById(userId, spaceId string) (*space, error)
        getSpacesByUser(userId string) (*[]space, error)
        updateSpace(userId string, s *space) error
        deleteSpace(userId, spaceId string) error
        setTabsForSpace(userId, spaceId string, t *[]tab) error
        getTabsForSpace(userId, spaceId string) (*[]tab, error)
        setGroupsForSpace(userId, spaceId string, g *[]group) error
        getGroupsForSpace(userId, spaceId string) (*[]group, error)
        addSnoozedTab(userId, spaceId string, t *SnoozedTab) error
        getAllSnoozedTabsByUser(userId string, lastSnoozedTabID int64) (*[]SnoozedTab, error)
        geSnoozedTabsInSpace(userId, spaceId string, lastSnoozedTabId int64) (*[]SnoozedTab, error)
        deleteSnoozedTab(userId, spaceId string, snoozedAt int64) error
        GetSnoozedTab(userId, spaceId string, snoozedAt int64) (*SnoozedTab, error)
}

type spaceRepo struct {
        db *db.DDB
}

func NewSpaceRepository(db *db.DDB) spaceRepository <span class="cov0" title="0">{
        return &amp;spaceRepo{
                db: db,
        }
}</span>

func (r spaceRepo) createSpace(userId string, s *space) error <span class="cov0" title="0">{
        av, err := attributevalue.MarshalMap(s)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't marshal space: %v. \n[Error]: %v", s, err)
                return err
        }</span>

        <span class="cov0" title="0">av[db.PK_NAME] = &amp;types.AttributeValueMemberS{Value: userId}
        av[db.SK_NAME] = &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.Space(s.Id)}

        _, err = r.db.Client.PutItem(context.TODO(), &amp;dynamodb.PutItemInput{
                TableName: &amp;r.db.TableName,
                Item:      av,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't create space: %v. \n[Error]: %v", s, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r spaceRepo) getSpaceById(userId, spaceId string) (*space, error) <span class="cov0" title="0">{

        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: userId},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.Space(spaceId)},
        }

        response, err := r.db.Client.GetItem(context.TODO(), &amp;dynamodb.GetItemInput{
                TableName: &amp;r.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get space for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(response.Item) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New(errMsg.spaceNotFound)
        }</span>

        <span class="cov0" title="0">s := &amp;space{}

        err = attributevalue.UnmarshalMap(response.Item, s)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal space for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if s.Id == "" </span><span class="cov0" title="0">{
                return nil, errors.New(errMsg.spaceGet)
        }</span>

        <span class="cov0" title="0">return s, nil</span>
}

func (r spaceRepo) getSpacesByUser(userId string) (*[]space, error) <span class="cov0" title="0">{

        key := expression.KeyAnd(expression.Key(db.PK_NAME).Equal(expression.Value(userId)), expression.Key(db.SK_NAME).BeginsWith(db.SORT_KEY.Space("")))

        expr, err := expression.NewBuilder().WithKeyCondition(key).Build()

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't build getSpacesByUser expression for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">response, err := r.db.Client.Query(context.TODO(), &amp;dynamodb.QueryInput{
                TableName:                 &amp;r.db.TableName,
                ExpressionAttributeNames:  expr.Names(),
                ExpressionAttributeValues: expr.Values(),
                KeyConditionExpression:    expr.KeyCondition(),
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get spaces for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(response.Items) &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New(errMsg.spaceNotFound)
        }</span>

        <span class="cov0" title="0">spaces := []space{}

        err = attributevalue.UnmarshalListOfMaps(response.Items, &amp;spaces)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal spaces for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;spaces, nil</span>
}

func (r spaceRepo) updateSpace(userId string, s *space) error <span class="cov0" title="0">{
        key := map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{Value: userId},
                "SK": &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.Space(s.Id)},
        }

        var update expression.UpdateBuilder

        // iterate over the fields of the struct
        v := reflect.ValueOf(s)

        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span> else<span class="cov0" title="0"> {
                logger.Error("unexpected type", errors.New(v.Kind().String()))
                return errors.ErrUnsupported
        }</span>

        <span class="cov0" title="0">t := v.Type()
        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                field := t.Field(i)
                fieldValue := v.Field(i)

                if fieldValue.IsZero() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">update = update.Set(expression.Name(field.Name), expression.Value(v.Field(i).Interface()))</span>
        }

        <span class="cov0" title="0">expr, err := expression.NewBuilder().WithUpdate(update).Build()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = r.db.Client.UpdateItem(context.TODO(), &amp;dynamodb.UpdateItemInput{
                TableName:                 &amp;r.db.TableName,
                Key:                       key,
                ExpressionAttributeNames:  expr.Names(),
                ExpressionAttributeValues: expr.Values(),
                UpdateExpression:          expr.Update(),
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't update space for userId: %v. \n[Error]: %v", userId, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r spaceRepo) deleteSpace(userId, spaceId string) error <span class="cov0" title="0">{

        key := map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{Value: userId},
                "SK": &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.Space(spaceId)},
        }

        _, err := r.db.Client.DeleteItem(context.TODO(), &amp;dynamodb.DeleteItemInput{
                TableName: &amp;r.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't delete space for userId: %v. \n[Error]: %v", userId, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// tabs
func (r spaceRepo) setTabsForSpace(userId, spaceId string, t *[]tab) error <span class="cov0" title="0">{

        tabs, err := attributevalue.MarshalListWithOptions(t)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't marshal tabs: %v. \n[Error]: %v", t, err)
                return err
        }</span>

        <span class="cov0" title="0">item := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: userId},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.TabsInSpace(spaceId)},
                "Tabs":     &amp;types.AttributeValueMemberL{Value: tabs},
        }

        _, err = r.db.Client.PutItem(context.TODO(), &amp;dynamodb.PutItemInput{
                TableName: &amp;r.db.TableName,
                Item:      item,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't set tabs for space for userId: %v. \n[Error]: %v", userId, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r spaceRepo) getTabsForSpace(userId, spaceId string) (*[]tab, error) <span class="cov0" title="0">{
        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: userId},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.TabsInSpace(spaceId)},
        }

        response, err := r.db.Client.GetItem(context.TODO(), &amp;dynamodb.GetItemInput{
                TableName: &amp;r.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get tabs for space for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(response.Item) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New(errMsg.tabsGet)
        }</span>

        <span class="cov0" title="0">tabsAttr, ok := response.Item["Tabs"]

        if !ok </span><span class="cov0" title="0">{
                errStr := fmt.Sprintf("Tab attribute not found for spaceId: %v for userId: %v", spaceId, userId)
                logger.Error(errStr, err)
                return nil, errors.New(errStr)
        }</span>

        <span class="cov0" title="0">tabs := []tab{}

        err = attributevalue.Unmarshal(tabsAttr, &amp;tabs)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal tabs for space for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;tabs, nil</span>
}

// groups
func (r spaceRepo) setGroupsForSpace(userId, spaceId string, g *[]group) error <span class="cov0" title="0">{
        groups, err := attributevalue.MarshalList(g)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't marshal groups: %v. \n[Error]: %v", g, err)
                return err
        }</span>

        <span class="cov0" title="0">item := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: userId},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.GroupsInSpace(spaceId)},
                "Groups":   &amp;types.AttributeValueMemberL{Value: groups},
        }
        _, err = r.db.Client.PutItem(context.TODO(), &amp;dynamodb.PutItemInput{
                TableName: &amp;r.db.TableName,
                Item:      item,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't set groups for space for userId: %v. \n[Error]: %v", userId, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func (r spaceRepo) getGroupsForSpace(userId, spaceId string) (*[]group, error) <span class="cov0" title="0">{
        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: userId},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.GroupsInSpace(spaceId)},
        }

        response, err := r.db.Client.GetItem(context.TODO(), &amp;dynamodb.GetItemInput{
                TableName: &amp;r.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get groups for space for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(response.Item) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New(errMsg.groupsGet)
        }</span>

        <span class="cov0" title="0">groupsAttr, ok := response.Item["Groups"]

        if !ok </span><span class="cov0" title="0">{
                errStr := fmt.Sprintf("Groups attribute not found for spaceId: %v for userId: %v", spaceId, userId)
                logger.Error(errStr, err)
                return nil, errors.New(errStr)
        }</span>

        <span class="cov0" title="0">groups := []group{}

        err = attributevalue.Unmarshal(groupsAttr, &amp;groups)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal groups for space for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;groups, nil</span>

}

// snoozed tabs
func (r spaceRepo) addSnoozedTab(userId, spaceId string, t *SnoozedTab) error <span class="cov0" title="0">{

        snoozedTabs, err := attributevalue.MarshalMap(*t)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't marshal snoozed tabs: %v. \n[Error]: %v", t, err)
                return err
        }</span>

        <span class="cov0" title="0">sk := fmt.Sprintf("%s#%v", db.SORT_KEY.SnoozedTabs(spaceId), t.SnoozedAt)

        snoozedTabs[db.PK_NAME] = &amp;types.AttributeValueMemberS{Value: userId}
        snoozedTabs[db.SK_NAME] = &amp;types.AttributeValueMemberS{Value: sk}

        _, err = r.db.Client.PutItem(context.TODO(), &amp;dynamodb.PutItemInput{
                TableName: &amp;r.db.TableName,
                Item:      snoozedTabs,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't add snoozed tab for userId: %v. \n[Error]: %v", userId, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r spaceRepo) GetSnoozedTab(userId, spaceId string, snoozedAt int64) (*SnoozedTab, error) <span class="cov0" title="0">{

        skSuffix := fmt.Sprintf("%s#%v", spaceId, snoozedAt)

        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: userId},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.SnoozedTabs(skSuffix)},
        }

        response, err := r.db.Client.GetItem(context.TODO(), &amp;dynamodb.GetItemInput{
                TableName: &amp;r.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get snoozed tab for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(response.Item) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New(errMsg.snoozedTabsNotFound)
        }</span>
        <span class="cov0" title="0">snoozedTab := &amp;SnoozedTab{}

        err = attributevalue.UnmarshalMap(response.Item, snoozedTab)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal snoozed tab for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return snoozedTab, nil</span>

}

func (r spaceRepo) getAllSnoozedTabsByUser(userId string, lastSnoozedTabId int64) (*[]SnoozedTab, error) <span class="cov0" title="0">{

        key := expression.KeyAnd(expression.Key(db.PK_NAME).Equal(expression.Value(userId)), expression.Key(db.SK_NAME).BeginsWith(db.SORT_KEY.SnoozedTabs("")))

        expr, err := expression.NewBuilder().WithKeyCondition(key).Build()

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't build getSnoozedTabs expression for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var startKey map[string]types.AttributeValue

        if lastSnoozedTabId != 0 </span><span class="cov0" title="0">{
                startKey = map[string]types.AttributeValue{
                        db.PK_NAME: &amp;types.AttributeValueMemberS{Value: userId},
                        db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.SnoozedTabs(fmt.Sprintf("%v", lastSnoozedTabId))},
                }
        }</span>

        <span class="cov0" title="0">response, err := r.db.Client.Query(context.TODO(), &amp;dynamodb.QueryInput{
                TableName:                 &amp;r.db.TableName,
                ExpressionAttributeNames:  expr.Names(),
                ExpressionAttributeValues: expr.Values(),
                KeyConditionExpression:    expr.KeyCondition(),
                Limit:                     aws.Int32(10),
                ExclusiveStartKey:         startKey,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get snoozed tabs for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(response.Items) &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New(errMsg.snoozedTabsNotFound)
        }</span>

        <span class="cov0" title="0">snoozedTabs := []SnoozedTab{}

        err = attributevalue.UnmarshalListOfMaps(response.Items, &amp;snoozedTabs)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal snoozed tabs for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;snoozedTabs, nil</span>
}

func (r spaceRepo) geSnoozedTabsInSpace(userId, spaceId string, lastSnoozedTabId int64) (*[]SnoozedTab, error) <span class="cov0" title="0">{

        key := expression.KeyAnd(expression.Key("PK").Equal(expression.Value(userId)), expression.Key("SK").BeginsWith(db.SORT_KEY.SnoozedTabs(spaceId)))

        expr, err := expression.NewBuilder().WithKeyCondition(key).Build()

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't build getSnoozedTabs expression for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">var startKey map[string]types.AttributeValue

        if lastSnoozedTabId != 0 </span><span class="cov0" title="0">{
                startKey = map[string]types.AttributeValue{
                        db.PK_NAME: &amp;types.AttributeValueMemberS{Value: userId},
                        db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.SnoozedTabs(fmt.Sprintf("%s#%v", spaceId, lastSnoozedTabId))},
                }
        }</span>

        <span class="cov0" title="0">response, err := r.db.Client.Query(context.TODO(), &amp;dynamodb.QueryInput{
                TableName:                 &amp;r.db.TableName,
                ExpressionAttributeNames:  expr.Names(),
                ExpressionAttributeValues: expr.Values(),
                KeyConditionExpression:    expr.KeyCondition(),
                Limit:                     aws.Int32(10),
                ExclusiveStartKey:         startKey,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get snoozed tabs for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(response.Items) &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New(errMsg.snoozedTabsGet)
        }</span>
        <span class="cov0" title="0">snoozedTabs := []SnoozedTab{}

        err = attributevalue.UnmarshalListOfMaps(response.Items, &amp;snoozedTabs)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal snoozed tabs for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;snoozedTabs, nil</span>
}

func (r spaceRepo) deleteSnoozedTab(userId, spaceId string, snoozedAt int64) error <span class="cov0" title="0">{
        sk := fmt.Sprintf("%s#%s", db.SORT_KEY.SnoozedTabs(spaceId), strconv.FormatInt(snoozedAt, 10))

        key := map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{Value: userId},
                "SK": &amp;types.AttributeValueMemberS{Value: sk},
        }

        _, err := r.db.Client.DeleteItem(context.TODO(), &amp;dynamodb.DeleteItemInput{
                TableName: &amp;r.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't delete snoozed tab for userId: %v. \n[Error]: %v", userId, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package spaces

import (
        "github.com/manishMandal02/tabsflow-backend/pkg/db"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
)

func Router() http_api.IRouter <span class="cov0" title="0">{

        db := db.New()
        sr := NewSpaceRepository(db)
        sh := newSpaceHandler(sr)

        // middleware to get userId from jwt token
        userIdMiddleware := newUserIdMiddleware()

        spacesRouter := http_api.NewRouter("/spaces")

        spacesRouter.Use(userIdMiddleware)

        // spaces
        spacesRouter.POST("/", sh.create)
        spacesRouter.GET("/my", sh.spacesByUser)
        spacesRouter.GET("/:id", sh.get)
        spacesRouter.PATCH("/", sh.update)
        spacesRouter.DELETE("/:spaceId", sh.delete)

        // tabs
        spacesRouter.GET("/:spaceId/tabs", sh.getTabsInSpace)
        spacesRouter.POST("/:spaceId/tabs", sh.setTabsInSpace)

        // groups
        spacesRouter.GET("/:spaceId/groups", sh.getGroupsInSpace)
        spacesRouter.POST("/:spaceId/groups", sh.setGroupsInSpace)

        // snoozed tabs
        spacesRouter.POST("/:spaceId/snoozed-tabs", sh.createSnoozedTab)
        spacesRouter.GET("/:spaceId/snoozed-tabs/:id", sh.getSnoozedTab)
        // query param: snoozedAt={timestamp}
        spacesRouter.GET("/snoozed-tabs/my", sh.getSnoozedTabByUser)
        // query param: snoozedAt={timestamp}
        spacesRouter.GET("/:spaceId/snoozed-tabs", sh.getSnoozedTabsBySpace)
        spacesRouter.DELETE("/:spaceId/snoozed-tabs/:id", sh.deleteSnoozedTab)

        // serve API routes
        return spacesRouter
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package spaces

import "github.com/go-playground/validator/v10"

type space struct {
        Id             string `json:"id" validate:"required"`
        Title          string `json:"title" validate:"required"`
        Theme          string `json:"theme" validate:"required"`
        IsSaved        bool   `json:"isSaved" validate:"required"`
        Emoji          string `json:"emoji" validate:"required"`
        WindowId       int    `json:"windowId" validate:"required,number"`
        ActiveTabIndex int    `json:"activeTabIndex" validate:"number"`
}

func (s space) validate() error <span class="cov0" title="0">{
        validate := validator.New(validator.WithRequiredStructEnabled())

        err := validate.Struct(s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type tab struct {
        Id      int    `json:"id"`
        URL     string `json:"url"`
        Title   string `json:"title"`
        Index   int    `json:"index"`
        Icon    string `json:"icon"`
        GroupId int    `json:"groupId"`
}

type group struct {
        Id        int    `json:"id"`
        Name      string `json:"name"`
        Theme     string `json:"theme"`
        Collapsed bool   `json:"collapsed"`
}

type SnoozedTab struct {
        URL          string `json:"url,omitempty"`
        Title        string `json:"title,omitempty"`
        Icon         string `json:"icon,omitempty"`
        SnoozedAt    int64  `json:"snoozedAt,omitempty"`
        SnoozedUntil int64  `json:"snoozedUntil,omitempty"`
}

var errMsg = struct {
        spaceNotFound       string
        spaceGet            string
        spaceId             string
        spaceCreate         string
        spaceUpdate         string
        spaceDelete         string
        spaceGetAllByUser   string
        tabsGet             string
        tabsSet             string
        groupsGet           string
        groupsSet           string
        snoozedTabsCreate   string
        snoozedTabsGet      string
        snoozedTabsNotFound string
        snoozedTabsDelete   string
}{
        spaceNotFound:       "Space not found",
        spaceGet:            "Error getting space",
        spaceId:             "Invalid space id",
        spaceCreate:         "Error creating space",
        spaceUpdate:         "Error updating space",
        spaceDelete:         "Error deleting space",
        spaceGetAllByUser:   "Error getting spaces for user",
        tabsGet:             "Error getting tabs",
        tabsSet:             "Error setting tabs",
        groupsGet:           "Error getting groups",
        groupsSet:           "Error setting groups",
        snoozedTabsNotFound: "Snoozed not found",
        snoozedTabsCreate:   "Error creating snoozed tab",
        snoozedTabsGet:      "Error getting snoozed tabs",
        snoozedTabsDelete:   "Error deleting snoozed tab",
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package users

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        paddle "github.com/PaddleHQ/paddle-go-sdk"
        "github.com/PaddleHQ/paddle-go-sdk/pkg/paddlenotification"
        "github.com/manishMandal02/tabsflow-backend/config"
        "github.com/manishMandal02/tabsflow-backend/pkg/events"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
        "github.com/manishMandal02/tabsflow-backend/pkg/utils"
)

type handler struct {
        r          repository
        emailQueue *events.Queue
        httpClient http_api.Client
}

func newHandler(r repository, q *events.Queue, c http_api.Client) *handler <span class="cov8" title="1">{
        return &amp;handler{
                r:          r,
                emailQueue: q,
                httpClient: c,
        }
}</span>

// profile handlers
func (h handler) userById(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        id := r.Header.Get("UserId")

        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, ErrMsg.InvalidUserId, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">user, err := h.r.getUserByID(id)

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == ErrMsg.UserNotFound </span><span class="cov0" title="0">{
                        http.Error(w, ErrMsg.UserNotFound, http.StatusBadRequest)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, ErrMsg.GetUser, http.StatusInternalServerError)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">http_api.SuccessResData(w, user)</span>
}

func (h handler) createUser(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{

        user, err := userFromJSON(r.Body)

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("decoding user from body at createUser()", err)
                http.Error(w, ErrMsg.CreateUser, http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">err = user.validate()

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("error validating user at createUser()", err)
                http.Error(w, ErrMsg.CreateUser, http.StatusBadRequest)
                return
        }</span>

        //  check if the user with this id
        <span class="cov8" title="1">userExists, err := h.r.getUserByID(user.Id)

        logger.Dev("userExists: %v", userExists)

        if err != nil &amp;&amp; err.Error() != ErrMsg.UserNotFound </span><span class="cov0" title="0">{
                http.Error(w, ErrMsg.GetUser, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if userExists != nil </span><span class="cov8" title="1">{
                http.Error(w, ErrMsg.UserExists, http.StatusBadRequest)
                return
        }</span>

        // check user id from auth service (api call)
        <span class="cov8" title="1">body := struct {
                Email string `json:"email"`
        }{
                Email: user.Email,
        }

        bodyJson, err := json.Marshal(body)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error marshaling json body", err)
                http.Error(w, ErrMsg.CreateUser, http.StatusBadRequest)
        }</span>

        <span class="cov8" title="1">headers := map[string]string{
                "Content-Type": "application/json",
        }

        p := "https"

        if config.LOCAL_DEV_ENV </span><span class="cov0" title="0">{
                p = "http"
        }</span>

        <span class="cov8" title="1">authServiceURL := fmt.Sprintf("%s://%s/auth/user/", p, r.Host)

        res, respBody, err := utils.MakeHTTPRequest(http.MethodGet, authServiceURL, headers, bodyJson, h.httpClient)

        if err != nil </span><span class="cov8" title="1">{
                logger.Errorf("Error fetching user id from Auth Service for email: %v. \n [Error]: %v", body.Email, err)
                http.Error(w, ErrMsg.CreateUser, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if res.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                logger.Errorf("User does not have a valid session profile for email: %v. \n [Error]: %v", body.Email, err)
                //  Logout
                http.Redirect(w, r, "/auth/logout", http.StatusTemporaryRedirect)
                return
        }</span>

        // check user id
        <span class="cov8" title="1">var userIdData struct {
                Data struct {
                        UserId string `json:"userId"`
                } `json:"data"`
        }

        err = json.Unmarshal([]byte(respBody), &amp;userIdData)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error un_marshaling user id data for email: %v. \n [Error]: %v", body.Email, err)
                http.Error(w, ErrMsg.CreateUser, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if userIdData.Data.UserId != user.Id </span><span class="cov8" title="1">{
                logger.Errorf("User Id mismatch for email: %v. \n [Error]: %v", body.Email, err)
                http.Redirect(w, r, "/auth/logout", http.StatusTemporaryRedirect)
                return
        }</span>

        <span class="cov8" title="1">err = h.r.insertUser(user)

        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, ErrMsg.CreateUser, http.StatusBadGateway)
                return
        }</span>

        <span class="cov8" title="1">logger.Info("user saved to db, with userId: %v", user.Id)

        err = setDefaultUserData(user, h.r, h.emailQueue)

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Error setting user default data", err)
                http.Error(w, ErrMsg.CreateUser, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">http_api.SuccessResMsg(w, "user created")</span>
}

func (h handler) updateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")

        var n struct {
                Name string `json:"fullName"`
        }

        err := json.NewDecoder(r.Body).Decode(&amp;n)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error un_marshaling name from JSON at updateUser()", err)
                http.Error(w, ErrMsg.UpdateUser, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.r.updateUser(id, n.Name)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrMsg.UpdateUser, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResMsg(w, "user updated")</span>
}

func (h handler) deleteUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        id := r.PathValue("id")

        err := h.r.deleteAccount(id)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrMsg.DeleteUser, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResMsg(w, "user deleted")</span>
}

// preferences handlers
func (h handler) getPreferences(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        id := r.PathValue("id")

        preferences, err := h.r.getAllPreferences(id)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrMsg.PreferencesGet, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResData(w, preferences)</span>

}

type updatePerfBody struct {
        Type string          `json:"type"`
        Data json.RawMessage `json:"data"`
}

func (h handler) updatePreferences(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")

        var updateB updatePerfBody

        err := json.NewDecoder(r.Body).Decode(&amp;updateB)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error un_marshaling preferences from req body at updatePreferences()", err)
                http.Error(w, ErrMsg.PreferencesUpdate, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">sk, subPref, err := parseSubPreferencesData(updateB)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrMsg.PreferencesUpdate, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err = h.r.updatePreferences(id, sk, *subPref)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrMsg.PreferencesUpdate, http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">http_api.SuccessResMsg(w, "preferences updated")</span>
}

// subscription handlers
func (h handler) getSubscription(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")

        subscription, err := h.r.getSubscription(id)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrMsg.SubscriptionGet, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResData(w, subscription)</span>
}

func (h handler) checkSubscriptionStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")

        s, err := h.r.getSubscription(id)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrMsg.SubscriptionGet, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">active := false

        if s != nil </span><span class="cov0" title="0">{
                active = s.Status == SubscriptionStatusActive
        }</span>

        <span class="cov0" title="0">if active </span><span class="cov0" title="0">{
                // if subscription is active, check the end date
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("error parsing subscription end date", err)
                        http.Error(w, ErrMsg.SubscriptionGet, http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">if s.End &lt; time.Now().UTC().Unix() </span><span class="cov0" title="0">{
                        active = false
                }</span>
        }

        <span class="cov0" title="0">status := struct {
                Active bool `json:"active"`
        }{
                Active: active,
        }

        http_api.SuccessResData(w, status)</span>

}

func (h handler) getPaddleURL(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")
        //  check if the user with this id

        userExits := checkUserExits(id, h.r, w)
        if !userExits </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">p, err := newPaddleClient()

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrMsg.SubscriptionPaddleURL, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">s, err := h.r.getSubscription(id)

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrMsg.SubscriptionGet, http.StatusBadGateway)
                return
        }</span>

        <span class="cov0" title="0">client := p.SubscriptionsClient
        res, err := client.GetSubscription(context.TODO(), &amp;paddle.GetSubscriptionRequest{
                SubscriptionID: s.Id,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error getting paddle subscription", err)
                http.Error(w, ErrMsg.SubscriptionPaddleURL, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">resBody := struct {
                CancelURL string `json:"cancelURL,omitempty"`
                UpdateURL string `json:"updateURL,omitempty"`
        }{}

        shouldSendCancelURL := r.URL.Query().Get("cancelURL") != ""

        if shouldSendCancelURL </span><span class="cov0" title="0">{
                resBody.CancelURL = res.ManagementURLs.Cancel
        }</span> else<span class="cov0" title="0"> {
                resBody.UpdateURL = *res.ManagementURLs.UpdatePaymentMethod
        }</span>

        <span class="cov0" title="0">if shouldSendCancelURL &amp;&amp; resBody.CancelURL == "" </span><span class="cov0" title="0">{
                http.Error(w, ErrMsg.SubscriptionPaddleURL, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if !shouldSendCancelURL &amp;&amp; resBody.UpdateURL == "" </span><span class="cov0" title="0">{
                http.Error(w, ErrMsg.SubscriptionPaddleURL, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">http_api.SuccessResData(w, resBody)</span>

}

// paddle webhook handler
func (h handler) subscriptionWebhook(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        v := paddle.NewWebhookVerifier(config.PADDLE_WEBHOOK_SECRET_KEY)

        ok, err := v.Verify(r)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error verifying paddle webhook", err)
                http.Error(w, "Error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                http.Error(w, "Error bad_request", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">body := r.Body

        http_api.SuccessResMsg(w, "event acknowledged")

        // process the event &gt;&lt;&gt; * &lt;&gt;&lt; &lt;&gt;&lt; &lt;&gt;&lt; &lt;&gt;&lt;

        // get the event type
        var ev paddle.GenericEvent

        err = json.NewDecoder(body).Decode(&amp;ev)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error decoding paddle webhook event", err)
                http.Error(w, "Error", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">switch ev.EventType </span>{
        case paddle.EventTypeNameSubscriptionCreated:<span class="cov0" title="0">
                var c paddlenotification.SubscriptionCreatedNotification

                data, err := json.Marshal(ev.Data)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("error marshaling paddle webhook event data", err)
                        return
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal(data, &amp;c); err != nil </span><span class="cov0" title="0">{
                        logger.Error("error parsing subscription data", err)
                        return
                }</span>

                <span class="cov0" title="0">userId, ok := c.CustomData["userId"].(string)

                if !ok </span><span class="cov0" title="0">{
                        logger.Errorf("userId not found in subscription created event data")
                        userId = "01929a76-ce53-7e0d-b712-41a9fa1178d8"
                }</span>

                <span class="cov0" title="0">subscriptionData := subscriptionData{
                        userId:         userId,
                        subscriptionId: c.ID,
                        priceId:        c.Items[0].Price.ID,
                        status:         string(c.Status),
                        startDate:      *c.StartedAt,
                        endDate:        c.CurrentBillingPeriod.EndsAt,
                        nextBillDate:   *c.NextBilledAt,
                }

                err = subscriptionEventHandler(h.r, &amp;subscriptionData, false)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error processing SubscriptionCreated event as subscriptionWebhook()", err)
                }</span>

        case paddle.EventTypeNameSubscriptionUpdated:<span class="cov0" title="0">
                var u paddlenotification.SubscriptionNotification

                data, err := json.Marshal(ev.Data)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("error marshaling paddle webhook event data", err)
                        return
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal(data, &amp;u); err != nil </span><span class="cov0" title="0">{
                        logger.Error("error parsing subscription data", err)
                        return
                }</span>

                <span class="cov0" title="0">userId, ok := u.CustomData["userId"].(string)

                if !ok </span><span class="cov0" title="0">{
                        logger.Errorf("userId not found in subscription created event data")
                        userId = "01929a76-ce53-7e0d-b712-41a9fa1178d8"
                }</span>

                <span class="cov0" title="0">subscriptionData := subscriptionData{
                        userId:         userId,
                        subscriptionId: u.ID,
                        priceId:        u.Items[0].Price.ID,
                        status:         string(u.Status),
                        startDate:      *u.StartedAt,
                        endDate:        u.CurrentBillingPeriod.EndsAt,
                        nextBillDate:   *u.NextBilledAt,
                }

                err = subscriptionEventHandler(h.r, &amp;subscriptionData, true)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Error processing SubscriptionUpdated event as subscriptionWebhook()", err)
                }</span>

        case paddle.EventTypeNameTransactionPaymentFailed:<span class="cov0" title="0">
                var f paddlenotification.TransactionNotification

                data, err := json.Marshal(ev.Data)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("error marshaling paddle webhook event data", err)
                        return
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal(data, &amp;f); err != nil </span><span class="cov0" title="0">{
                        logger.Error("error parsing payment failed event data", err)
                        return
                }</span>

                <span class="cov0" title="0">userId, ok := f.CustomData["userId"].(string)

                if !ok </span><span class="cov0" title="0">{
                        logger.Errorf("userId not found in subscription created event data")
                }</span>

                <span class="cov0" title="0">logger.Dev("userId: %v", userId)</span>

                // TODO: handle payment failed
                // show a notification to the user
                // send an email only if paddle doesn't send a payment failed email

        default:<span class="cov0" title="0">
                logger.Errorf("not handling paddle webhook event_type: %v", ev.EventType)</span>
        }

}
</pre>
		
		<pre class="file" id="file29" style="display: none">package users

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "sync"
        "time"

        paddle "github.com/PaddleHQ/paddle-go-sdk"
        "github.com/manishMandal02/tabsflow-backend/config"
        "github.com/manishMandal02/tabsflow-backend/pkg/db"
        "github.com/manishMandal02/tabsflow-backend/pkg/events"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

// middleware to get userId from header ( set by authorizer after validating jwt token claims)
// also check if user exits
func newUserMiddleware(ur repository) http_api.Handler <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                userId := r.Header.Get("UserId")

                if userId == "" || !checkUserExits(userId, ur, w) </span><span class="cov0" title="0">{
                        http.Redirect(w, r, "/logout", http.StatusTemporaryRedirect)
                        return
                }</span>

                <span class="cov0" title="0">r.SetPathValue("id", userId)</span>
        }
}

func setDefaultUserPreferences(userId string, r repository) error <span class="cov8" title="1">{

        pref := make(map[string]interface{})

        pref[db.SORT_KEY.P_General] = &amp;defaultUserPref.General
        pref[db.SORT_KEY.P_CmdPalette] = &amp;defaultUserPref.CmdPalette
        pref[db.SORT_KEY.P_Note] = &amp;defaultUserPref.Notes
        pref[db.SORT_KEY.P_LinkPreview] = &amp;defaultUserPref.LinkPreview
        pref[db.SORT_KEY.P_AutoDiscard] = &amp;defaultUserPref.AutoDiscard

        var wg sync.WaitGroup

        for k, v := range pref </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(userId, k string, v interface{}) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        err := r.setPreferences(userId, k, v)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Error setting default preferences for userId: %v\n. data: %v.  \n[Error]: %v", userId, v, err)
                        }</span>
                }(userId, k, v)
        }

        <span class="cov8" title="1">wg.Wait()

        return nil</span>

}

func setDefaultUserData(user *User, r repository, emailQueue *events.Queue) error <span class="cov8" title="1">{
        // set default preferences for user
        err := setDefaultUserPreferences(user.Id, r)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">today := time.Now().UTC()

        trialEndDate := time.Date(
                today.Year(),
                today.Month(),
                today.Day()+config.TRAIL_DAYS,
                23, // hour
                59, // min
                59, // sec
                0,  // nano sec
                time.UTC,
        )

        //  start trail subscription
        s := &amp;subscription{
                Plan:   SubscriptionPlanTrial,
                Status: SubscriptionStatusActive,
                Start:  today.Unix(),
                End:    trialEndDate.Unix(),
        }

        err = r.setSubscription(user.Id, s)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // send USER_REGISTERED event to email service (queue)
        <span class="cov8" title="1">event := events.New(events.EventTypeUserRegistered, &amp;events.UserRegisteredPayload{
                Email:        user.Email,
                Name:         user.FullName,
                TrailEndDate: trialEndDate.Format(time.DateOnly),
        })

        err = emailQueue.AddMessage(event)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>

}

func checkUserExits(id string, r repository, w http.ResponseWriter) bool <span class="cov0" title="0">{

        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, ErrMsg.InvalidUserId, http.StatusBadRequest)
                return false
        }</span>

        //  check if the user with this id
        <span class="cov0" title="0">userExists, err := r.getUserByID(id)

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == ErrMsg.UserNotFound </span><span class="cov0" title="0">{
                        http.Error(w, ErrMsg.UserNotFound, http.StatusBadRequest)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, ErrMsg.GetUser, http.StatusInternalServerError)
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        <span class="cov0" title="0">if userExists == nil </span><span class="cov0" title="0">{
                http.Error(w, ErrMsg.UserNotFound, http.StatusNotFound)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// unmarshal json to sub preference struct
func unmarshalSubPref[T any](data json.RawMessage) (*T, error) <span class="cov8" title="1">{
        var pref T
        if err := json.Unmarshal(data, &amp;pref); err != nil </span><span class="cov8" title="1">{
                return &amp;pref, err
        }</span>

        <span class="cov8" title="1">return &amp;pref, nil</span>
}

// associate req body data to a sub preference struct of a specific type
func parseSubPreferencesData(perfBody updatePerfBody) (string, *interface{}, error) <span class="cov8" title="1">{
        var subP interface{}
        var err error

        sk := fmt.Sprintf("P#%s", perfBody.Type)
        switch sk </span>{
        case db.SORT_KEY.P_General:<span class="cov8" title="1">
                subP, err = unmarshalSubPref[generalP](perfBody.Data)</span>
        case db.SORT_KEY.P_CmdPalette:<span class="cov0" title="0">
                subP, err = unmarshalSubPref[cmdPaletteP](perfBody.Data)</span>
        case db.SORT_KEY.P_AutoDiscard:<span class="cov0" title="0">
                subP, err = unmarshalSubPref[autoDiscardP](perfBody.Data)</span>
        case db.SORT_KEY.P_Note:<span class="cov0" title="0">
                subP, err = unmarshalSubPref[notesP](perfBody.Data)</span>
        case db.SORT_KEY.P_LinkPreview:<span class="cov0" title="0">
                subP, err = unmarshalSubPref[linkPreviewP](perfBody.Data)</span>
        default:<span class="cov8" title="1">
                err = fmt.Errorf("invalid preference sub type: %s", sk)</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                logger.Errorf("Error  un_marshaling sub preferences[Error]:  %v", err)
                return "", nil, err
        }</span>

        <span class="cov8" title="1">return sk, &amp;subP, nil</span>
}

// create a new instance of paddle sdk with configs
func newPaddleClient() (*paddle.SDK, error) <span class="cov0" title="0">{
        client, err := paddle.New(config.PADDLE_API_KEY)

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error creating paddle client", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// get subscription plan type from paddle pice id
func parsePaddlePlan(priceId string) *SubscriptionPlan <span class="cov0" title="0">{

        plan := SubscriptionPlanTrial

        if priceId == paddlePlanId.yearly </span><span class="cov0" title="0">{
                plan = SubscriptionPlanYearly
        }</span>

        <span class="cov0" title="0">if priceId == paddlePlanId.lifeTime </span><span class="cov0" title="0">{
                plan = SubscriptionPlanLifetime
        }</span>

        <span class="cov0" title="0">return &amp;plan</span>
}

type subscriptionData struct {
        userId         string
        subscriptionId string
        status         string
        priceId        string
        startDate      string
        endDate        string
        nextBillDate   string
}

// process paddle subscription (create/update) event in webhook
func subscriptionEventHandler(r repository, data *subscriptionData, isUpdatedEvent bool) error <span class="cov0" title="0">{
        // parse date to convert it to unix timestamp for db
        startDate, err := time.Parse(time.RFC3339, data.startDate)
        endDate, err2 := time.Parse(time.RFC3339, data.endDate)
        nextBillDate, err3 := time.Parse(time.RFC3339, data.nextBillDate)

        if err != nil || err2 != nil || err3 != nil </span><span class="cov0" title="0">{
                logger.Errorf("subscriptionEventHandler(): error parsing subscription dates: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">if data.userId == "" </span><span class="cov0" title="0">{
                ErrMsg := "error getting userId from event custom data subscriptionWebhook()"
                logger.Errorf("%v", ErrMsg)
                return errors.New(ErrMsg)
        }</span>

        <span class="cov0" title="0">plan := *parsePaddlePlan(data.priceId)

        s := &amp;subscription{
                Id:     data.subscriptionId,
                Plan:   plan,
                Status: SubscriptionStatus(data.status),
                Start:  startDate.Unix(),
                End:    endDate.Unix(),
        }

        if plan == SubscriptionPlanYearly </span><span class="cov0" title="0">{
                // save next bill date if, subscription plan is yearly
                s.NextBillDate = nextBillDate.Unix()
        }</span>

        <span class="cov0" title="0">if isUpdatedEvent </span><span class="cov0" title="0">{
                err = r.updateSubscription(data.userId, s)

        }</span> else<span class="cov0" title="0"> {
                err = r.setSubscription(data.userId, s)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package users

import (
        "context"
        "errors"
        "fmt"
        "reflect"
        "sync"
        "time"

        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
        "github.com/manishMandal02/tabsflow-backend/pkg/db"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

type repository interface {
        getUserByID(id string) (*User, error)
        insertUser(user *User) error
        updateUser(id, name string) error
        deleteAccount(id string) error
        getAllPreferences(id string) (*preferences, error)
        setPreferences(userId, sk string, pData interface{}) error
        updatePreferences(userId, sk string, pData interface{}) error
        getSubscription(userId string) (*subscription, error)
        setSubscription(userId string, s *subscription) error
        updateSubscription(userId string, sData *subscription) error
}

type userRepo struct {
        db *db.DDB
}

func newRepository(db *db.DDB) repository <span class="cov8" title="1">{
        return &amp;userRepo{
                db: db,
        }
}</span>

// profile
func (r *userRepo) getUserByID(id string) (*User, error) <span class="cov8" title="1">{

        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: id},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.Profile},
        }

        response, err := r.db.Client.GetItem(context.TODO(), &amp;dynamodb.GetItemInput{
                TableName: &amp;r.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't query for userId: %v. \n[Error]: %v", id, err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if response == nil || response.Item == nil </span><span class="cov8" title="1">{
                return nil, errors.New(ErrMsg.UserNotFound)
        }</span>

        <span class="cov8" title="1">if _, ok := response.Item["PK"]; !ok </span><span class="cov0" title="0">{
                return nil, errors.New(ErrMsg.UserNotFound)
        }</span>

        <span class="cov8" title="1">user := &amp;User{}

        err = attributevalue.UnmarshalMap(response.Item, &amp;user)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal query result for user_id: %v. \n[Error]: %v", id, err)
                return nil, err
        }</span>

        <span class="cov8" title="1">if user.Id == "" </span><span class="cov0" title="0">{
                return nil, errors.New(ErrMsg.UserNotFound)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func (r *userRepo) insertUser(user *User) error <span class="cov8" title="1">{
        profile := userWithSK{
                User: user,
                SK:   db.SORT_KEY.Profile,
        }

        item, err := attributevalue.MarshalMap(profile)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't marshal user: %#v. \n[Error]: %v", user, err)
                return err
        }</span>

        <span class="cov8" title="1">_, err = r.db.Client.PutItem(context.TODO(), &amp;dynamodb.PutItemInput{
                TableName: &amp;r.db.TableName,
                Item:      item,
        })

        if err != nil </span><span class="cov8" title="1">{
                logger.Errorf("Couldn't put item for userId: %v. \n[Error]: %v", user.Id, err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r userRepo) updateUser(id, name string) error <span class="cov0" title="0">{

        key := map[string]types.AttributeValue{
                db.PK_NAME: &amp;types.AttributeValueMemberS{Value: id},
                db.SK_NAME: &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.Profile},
        }

        // build update expression
        updateExpr := expression.Set(expression.Name("FullName"), expression.Value(name))
        expr, err := expression.NewBuilder().WithUpdate(updateExpr).Build()

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't build expression for updateUser query for the user_id: %v. \n[Error]: %v", id, err)
                return err
        }</span>

        // execute the query
        <span class="cov0" title="0">_, err = r.db.Client.UpdateItem(context.TODO(), &amp;dynamodb.UpdateItemInput{
                TableName:                 &amp;r.db.TableName,
                Key:                       key,
                ExpressionAttributeNames:  expr.Names(),
                ExpressionAttributeValues: expr.Values(),
                UpdateExpression:          expr.Update(),
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't updateUser, user_id: %v. \n[Error]: %v", id, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// delete user account with all their data
func (r userRepo) deleteAccount(id string) error <span class="cov0" title="0">{

        allSKs, err := r.db.GetAllSKs(id)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get all SKs for userId: %v. \n[Error]: %v", id, err)
                return err
        }</span>

        // channel to collect errors from goroutines
        <span class="cov0" title="0">errChan := make(chan error, len(allSKs)/db.DDB_MAX_BATCH_SIZE+1)

        var wg sync.WaitGroup

        // context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        reqs := []types.WriteRequest{}

        for _, sk := range allSKs </span><span class="cov0" title="0">{
                reqs = append(reqs, types.WriteRequest{
                        DeleteRequest: &amp;types.DeleteRequest{
                                Key: map[string]types.AttributeValue{
                                        db.PK_NAME: &amp;types.AttributeValueMemberS{Value: id},
                                        db.SK_NAME: &amp;types.AttributeValueMemberS{Value: sk},
                                },
                        },
                })
        }</span>

        <span class="cov0" title="0">r.db.BatchWriter(ctx, &amp;wg, errChan, reqs)

        // Wait for all goroutines to complete
        go func() </span><span class="cov0" title="0">{
                wg.Wait()
                close(errChan)
        }</span>()

        // Collect errors
        <span class="cov0" title="0">var errs []error
        for err := range errChan </span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span>

        // Return combined errors if any
        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("delete search index errors: %v", errs)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// preferences
func (r userRepo) getAllPreferences(id string) (*preferences, error) <span class="cov0" title="0">{
        // primary key - partition+sort key
        keyCondition := expression.KeyAnd(expression.Key("PK").Equal(expression.Value(id)), expression.Key("SK").BeginsWith(db.SORT_KEY.PreferencesBase))

        expr, err := expression.NewBuilder().WithKeyCondition(keyCondition).Build()

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't build getPreferences expression for userId: %#v. \n[Error]: %v", id, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">response, err := r.db.Client.Query(context.TODO(), &amp;dynamodb.QueryInput{
                TableName:                 &amp;r.db.TableName,
                ExpressionAttributeNames:  expr.Names(),
                ExpressionAttributeValues: expr.Values(),
                KeyConditionExpression:    expr.KeyCondition(),
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get preferences for userId : %#v. \n[Error]: %v", id, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(response.Items) &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New(ErrMsg.PreferencesGet)
        }</span>
        <span class="cov0" title="0">p, err := unMarshalPreferences(response)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return p, nil</span>
}

func (r userRepo) setPreferences(userId, sk string, pData interface{}) error <span class="cov8" title="1">{
        av, err := attributevalue.MarshalMap(pData)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">av["PK"] = &amp;types.AttributeValueMemberS{Value: userId}
        av["SK"] = &amp;types.AttributeValueMemberS{Value: sk}

        _, err = r.db.Client.PutItem(context.TODO(), &amp;dynamodb.PutItemInput{
                TableName: &amp;r.db.TableName,
                Item:      av,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r userRepo) updatePreferences(userId, sk string, pData interface{}) error <span class="cov0" title="0">{

        key := map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{Value: userId},
                "SK": &amp;types.AttributeValueMemberS{Value: sk},
        }

        var update expression.UpdateBuilder

        // iterate over the fields of the struct
        v := reflect.ValueOf(pData)

        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span> else<span class="cov0" title="0"> {
                logger.Error("unexpected type", errors.New(v.Kind().String()))
                return errors.ErrUnsupported
        }</span>

        <span class="cov0" title="0">t := v.Type()
        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                field := t.Field(i)
                fieldValue := v.Field(i)

                if fieldValue.IsZero() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">update = update.Set(expression.Name(field.Name), expression.Value(v.Field(i).Interface()))</span>
        }

        <span class="cov0" title="0">expr, err := expression.NewBuilder().WithUpdate(update).Build()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = r.db.Client.UpdateItem(context.TODO(), &amp;dynamodb.UpdateItemInput{
                TableName:                 &amp;r.db.TableName,
                Key:                       key,
                ExpressionAttributeNames:  expr.Names(),
                ExpressionAttributeValues: expr.Values(),
                UpdateExpression:          expr.Update(),
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't update preferences for userId: %v. \n[Error]: %v", userId, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// subscription
func (r userRepo) getSubscription(userId string) (*subscription, error) <span class="cov0" title="0">{

        key := map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{Value: userId},
                "SK": &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.Subscription},
        }

        response, err := r.db.Client.GetItem(context.TODO(), &amp;dynamodb.GetItemInput{
                TableName: &amp;r.db.TableName,
                Key:       key,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't get subscription for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(response.Item) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New(ErrMsg.SubscriptionGet)
        }</span>
        <span class="cov0" title="0">s := &amp;subscription{}

        err = attributevalue.UnmarshalMap(response.Item, s)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't unmarshal subscription for userId: %v. \n[Error]: %v", userId, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return s, nil</span>

}

func (r userRepo) setSubscription(userId string, s *subscription) error <span class="cov8" title="1">{

        av, err := attributevalue.MarshalMap(s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">av["PK"] = &amp;types.AttributeValueMemberS{Value: userId}
        av["SK"] = &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.Subscription}

        _, err = r.db.Client.PutItem(context.TODO(), &amp;dynamodb.PutItemInput{
                TableName: &amp;r.db.TableName,
                Item:      av,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't set subscription for userId: %v. \n[Error]: %v", userId, err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r userRepo) updateSubscription(userId string, sData *subscription) error <span class="cov0" title="0">{
        key := map[string]types.AttributeValue{
                "PK": &amp;types.AttributeValueMemberS{Value: userId},
                "SK": &amp;types.AttributeValueMemberS{Value: db.SORT_KEY.Subscription},
        }

        var update expression.UpdateBuilder

        // iterate over the fields of the struct
        v := reflect.ValueOf(sData)

        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span> else<span class="cov0" title="0"> {
                logger.Error("unexpected type", errors.New(v.Kind().String()))
                return errors.ErrUnsupported
        }</span>

        <span class="cov0" title="0">t := v.Type()
        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                field := t.Field(i)
                fieldValue := v.Field(i)

                if fieldValue.IsZero() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">update = update.Set(expression.Name(field.Name), expression.Value(v.Field(i).Interface()))</span>
        }

        <span class="cov0" title="0">expr, err := expression.NewBuilder().WithUpdate(update).Build()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = r.db.Client.UpdateItem(context.TODO(), &amp;dynamodb.UpdateItemInput{
                TableName:                 &amp;r.db.TableName,
                Key:                       key,
                ExpressionAttributeNames:  expr.Names(),
                ExpressionAttributeValues: expr.Values(),
                UpdateExpression:          expr.Update(),
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Couldn't update subscription for userId: %v. \n[Error]: %v", userId, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// * helpers
func unMarshalPreferences(res *dynamodb.QueryOutput) (*preferences, error) <span class="cov0" title="0">{

        w := func(item map[string]types.AttributeValue, v interface{}) error </span><span class="cov0" title="0">{

                if err := attributevalue.UnmarshalMap(item, &amp;v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">var err error

        p := &amp;preferences{}

        for _, item := range res.Items </span><span class="cov0" title="0">{
                sk := item["SK"].(*types.AttributeValueMemberS).Value
                switch sk </span>{
                case "P#General":<span class="cov0" title="0">
                        err = w(item, &amp;p.General)</span>
                case "P#CmdPalette":<span class="cov0" title="0">
                        err = w(item, &amp;p.CmdPalette)</span>

                case "P#Notes":<span class="cov0" title="0">
                        err = w(item, &amp;p.Notes)</span>

                case "P#AutoDiscard":<span class="cov0" title="0">
                        err = w(item, &amp;p.AutoDiscard)</span>

                case "P#LinkPreview":<span class="cov0" title="0">
                        err = w(item, &amp;p.LinkPreview)</span>

                }
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Couldn't unmarshal preferences", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return p, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package users

import (
        "github.com/manishMandal02/tabsflow-backend/pkg/db"
        "github.com/manishMandal02/tabsflow-backend/pkg/events"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
)

func Router(db *db.DDB, q *events.Queue, c http_api.Client) http_api.IRouter <span class="cov8" title="1">{

        r := newRepository(db)

        handler := newHandler(r, q, c)

        usersRouter := http_api.NewRouter("/users")

        checkUserMiddleware := newUserMiddleware(r)

        // profile
        usersRouter.GET("/me", handler.userById)
        usersRouter.POST("/", handler.createUser)
        usersRouter.PATCH("/", checkUserMiddleware, handler.updateUser)
        // TODO: test delete handler after adding more data
        usersRouter.DELETE("/", checkUserMiddleware, handler.deleteUser)

        // preferences
        usersRouter.GET("/preferences", checkUserMiddleware, handler.getPreferences)
        usersRouter.PATCH("/preferences", checkUserMiddleware, handler.updatePreferences)

        // subscription
        usersRouter.GET("/subscription", checkUserMiddleware, handler.getSubscription)
        usersRouter.GET("/subscription/status", checkUserMiddleware, handler.checkSubscriptionStatus)
        // queries - cancelURL:bool
        usersRouter.GET("/subscription/paddle-url", checkUserMiddleware, handler.getPaddleURL)
        usersRouter.POST("/subscription/webhook", handler.subscriptionWebhook)

        // serve API routes
        return usersRouter
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package users

import (
        "encoding/json"
        "io"

        "github.com/go-playground/validator/v10"
)

type User struct {
        Id         string `json:"id" dynamodbav:"PK" validate:"required"`
        FullName   string `json:"fullName" dynamodbav:"FullName" validate:"required"`
        Email      string `json:"email" dynamodbav:"Email" validate:"required,email"`
        ProfilePic string `json:"profilePic" dynamodbav:"ProfilePic" validate:"url"`
}

type userWithSK struct {
        *User
        SK string `json:"sk" dynamodbav:"SK"`
}

func userFromJSON(body io.Reader) (*User, error) <span class="cov8" title="1">{

        var u *User

        err := json.NewDecoder(body).Decode(&amp;u)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return u, nil</span>

}

func (u *User) validate() error <span class="cov8" title="1">{
        validate := validator.New(validator.WithRequiredStructEnabled())

        err := validate.Struct(u)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>

}

type SubscriptionPlan string

const (
        SubscriptionPlanTrial    SubscriptionPlan = "TRAIL"
        SubscriptionPlanYearly   SubscriptionPlan = "YEARLY"
        SubscriptionPlanLifetime SubscriptionPlan = "LIFE_TIME"
)

// paddle plan/price id
var paddlePlanId = struct {
        yearly   string
        lifeTime string
}{
        yearly:   "pri_01j9gharmwn4ev55kyzywy447w",
        lifeTime: "pri_01j9gh59zz1cs1zafbn95375h1",
}

type SubscriptionStatus string

const (
        SubscriptionStatusActive   SubscriptionStatus = "active"
        SubscriptionStatusCanceled SubscriptionStatus = "canceled"
        SubscriptionStatusPastDue  SubscriptionStatus = "past_due"
        SubscriptionStatusPaused   SubscriptionStatus = "paused"
        SubscriptionStatusTrialing SubscriptionStatus = "trialing"
)

type subscription struct {
        Id           string             `json:"id" dynamodbav:"Id"`
        Plan         SubscriptionPlan   `json:"plan" dynamodbav:"Plan"`
        Status       SubscriptionStatus `json:"status" dynamodbav:"Status"`
        Start        int64              `json:"start" dynamodbav:"Start"`
        End          int64              `json:"end" dynamodbav:"End"`
        NextBillDate int64              `json:"nextBillDate,omitempty" dynamodbav:"NextBillDate,omitempty"`
}

type generalP struct {
        OpenSpace           string `json:"openSpace,omitempty" dynamodbav:"OpenSpace"`
        DeleteUnsavedSpaces string `json:"deleteUnsavedSpaces,omitempty" dynamodbav:"DeleteUnsavedSpaces"`
}

type searchP struct {
        Bookmarks bool `json:"bookmarks,omitempty" dynamodbav:"Bookmarks"`
        Notes     bool `json:"notes,omitempty" dynamodbav:"Notes"`
}

type cmdPaletteP struct {
        IsDisabled       bool     `json:"isDisabled,omitempty" dynamodbav:"IsDisabled"`
        Search           searchP  `json:"search,omitempty" dynamodbav:"Search"`
        DisabledCommands []string `json:"disabledCommands,omitempty" dynamodbav:"DisabledCommands"`
}

type notesP struct {
        IsDisabled     bool   `json:"isDisabled,omitempty" dynamodbav:"IsDisabled"`
        BubblePos      string `json:"bubblePos,omitempty" dynamodbav:"BubblePos"`
        ShowOnAllSites bool   `json:"showOnAllSites,omitempty" dynamodbav:"ShowOnAllSites"`
}
type autoDiscardP struct {
        IsDisabled              bool     `json:"isDisabled,omitempty" dynamodbav:"IsDisabled"`
        DiscardTabsAfterIdleMin int32    `json:"DiscardTabsAfterIdleMin,omitempty" dynamodbav:"DiscardTabsAfterIdleMin"`
        WhitelistedDomains      []string `json:"whitelistedDomains,omitempty" dynamodbav:"WhitelistedDomains"`
}

type linkPreviewP struct {
        IsDisabled  bool   `json:"isDisabled,omitempty" dynamodbav:"IsDisabled"`
        OpenTrigger string `json:"openTrigger,omitempty" dynamodbav:"openTrigger"`
        Size        string `json:"size,omitempty" dynamodbav:"Size"`
}

type preferences struct {
        General     generalP     `json:"general,omitempty" dynamodbav:"P#General"`
        CmdPalette  cmdPaletteP  `json:"cmdPalette,omitempty" dynamodbav:"P#CmdPalette"`
        Notes       notesP       `json:"notes,omitempty" dynamodbav:"P#Notes"`
        AutoDiscard autoDiscardP `json:"autoDiscard,omitempty" dynamodbav:"P#AutoDiscard"`
        LinkPreview linkPreviewP `json:"linkPreview,omitempty" dynamodbav:"P#LinkPreview"`
}

var defaultUserPref = preferences{
        General: generalP{
                OpenSpace:           "newWindow",
                DeleteUnsavedSpaces: "week",
        },
        CmdPalette: cmdPaletteP{
                IsDisabled:       false,
                Search:           searchP{Bookmarks: true, Notes: true},
                DisabledCommands: []string{},
        },
        Notes: notesP{
                IsDisabled:     false,
                BubblePos:      "bottom-right",
                ShowOnAllSites: true,
        },
        AutoDiscard: autoDiscardP{
                IsDisabled:              false,
                DiscardTabsAfterIdleMin: 10,
                WhitelistedDomains:      []string{},
        },
        LinkPreview: linkPreviewP{
                IsDisabled:  false,
                OpenTrigger: "shift-click",
                Size:        "tablet",
        },
}

var ErrMsg = struct {
        GetUser               string
        UserNotFound          string
        UserExists            string
        CreateUser            string
        UpdateUser            string
        DeleteUser            string
        InvalidUserId         string
        PreferencesGet        string
        PreferencesUpdate     string
        SubscriptionGet       string
        SubscriptionUpdate    string
        SubscriptionCheck     string
        SubscriptionPaddleURL string
}{
        GetUser:               "Error getting user",
        UserNotFound:          "User not found",
        UserExists:            "User already exits",
        CreateUser:            "Error creating user",
        UpdateUser:            "Error updating user",
        DeleteUser:            "Error deleting user",
        InvalidUserId:         "Invalid user id",
        PreferencesGet:        "Error getting preferences",
        PreferencesUpdate:     "Error updating preferences",
        SubscriptionGet:       "Error getting subscription",
        SubscriptionUpdate:    "Error updating subscription",
        SubscriptionCheck:     "Error checking subscription status",
        SubscriptionPaddleURL: "Error getting paddle url",
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package db

import (
        "context"
        "time"

        "github.com/aws/aws-sdk-go-v2/service/dynamodb"

        "github.com/manishMandal02/tabsflow-backend/config"
        "golang.org/x/time/rate"
)

type DynamoDBClientInterface interface {
        GetItem(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error)
        PutItem(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error)
        UpdateItem(ctx context.Context, params *dynamodb.UpdateItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.UpdateItemOutput, error)
        DeleteItem(ctx context.Context, params *dynamodb.DeleteItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.DeleteItemOutput, error)
        Query(ctx context.Context, params *dynamodb.QueryInput, optFns ...func(*dynamodb.Options)) (*dynamodb.QueryOutput, error)
        BatchGetItem(ctx context.Context, params *dynamodb.BatchGetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.BatchGetItemOutput, error)
        BatchWriteItem(ctx context.Context, params *dynamodb.BatchWriteItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.BatchWriteItemOutput, error)
}

type DDB struct {
        Client    DynamoDBClientInterface
        TableName string
        Limiter   *rate.Limiter
}

// new instance of main table
func New() *DDB <span class="cov0" title="0">{
        return &amp;DDB{
                Client:    newDBB(),
                TableName: config.DDB_MAIN_TABLE_NAME,
                Limiter:   newLimiter(),
        }
}</span>

// new instance of session table
func NewSessionTable() *DDB <span class="cov0" title="0">{
        return &amp;DDB{
                Client:    newDBB(),
                TableName: config.DDB_SESSIONS_TABLE_NAME,
        }
}</span>

// new instance od search index table
func NewSearchIndexTable() *DDB <span class="cov0" title="0">{
        return &amp;DDB{
                Client:    newDBB(),
                TableName: config.DDB_SEARCH_INDEX_TABLE_NAME,
                Limiter:   newLimiter(),
        }
}</span>

// new db client helper internal helper
func newDBB() *dynamodb.Client <span class="cov0" title="0">{
        return dynamodb.NewFromConfig(config.AWS_CONFIG)
}</span>

func newLimiter() *rate.Limiter <span class="cov0" title="0">{
        return rate.NewLimiter(rate.Every(20*time.Millisecond), 10)
}</span>

const (
        DDB_MAX_BATCH_SIZE int    = 25
        PK_NAME            string = "PK"
        SK_NAME            string = "SK"
)

// sort keys
type keySuffix func(s string) string

func generateKey(base string) keySuffix <span class="cov8" title="1">{
        return func(id string) string </span><span class="cov0" title="0">{
                return base + id
        }</span>
}

var SORT_KEY = struct {
        Profile                  string
        Subscription             string
        UsageAnalytics           string
        PreferencesBase          string
        P_General                string
        P_Note                   string
        P_CmdPalette             string
        P_LinkPreview            string
        P_AutoDiscard            string
        NotificationSubscription string
        Notifications            keySuffix
        Space                    keySuffix
        TabsInSpace              keySuffix
        GroupsInSpace            keySuffix
        SnoozedTabs              keySuffix
        Notes                    keySuffix
}{
        Profile:                  "P#Profile",
        Subscription:             "U#Subscription",
        UsageAnalytics:           "U#UsageAnalytics",
        PreferencesBase:          "P#",
        P_General:                "P#General",
        P_Note:                   "P#Note",
        P_CmdPalette:             "P#CmdPalette",
        P_LinkPreview:            "P#LinkPreview",
        P_AutoDiscard:            "P#AutoDiscard",
        NotificationSubscription: "U#NotificationSubscription",
        Notifications:            generateKey("U#Notification#"),
        Space:                    generateKey("S#Info#"),
        TabsInSpace:              generateKey("S#Tabs#"),
        GroupsInSpace:            generateKey("S#Groups#"),
        SnoozedTabs:              generateKey("S#SnoozedTabs#"),
        Notes:                    generateKey("N#"),
}

var SORT_KEY_SESSIONS = struct {
        Session keySuffix
        OTP     keySuffix
        UserId  keySuffix
}{
        Session: generateKey("Session#"),
        OTP:     generateKey("OTP#"),
        UserId:  generateKey("UserId#"),
}

var SORT_KEY_SEARCH_INDEX = struct {
        Note keySuffix
}{
        Note: generateKey("N#"),
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package db

import (
        "context"
        "fmt"
        "math"
        "math/rand/v2"
        "sync"
        "time"

        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

func getAllStaticSKs() []string <span class="cov0" title="0">{
        return []string{
                SORT_KEY.Profile,
                SORT_KEY.Subscription,
                SORT_KEY.UsageAnalytics,
                SORT_KEY.P_General,
                SORT_KEY.P_Note,
                SORT_KEY.P_CmdPalette,
                SORT_KEY.P_LinkPreview,
                SORT_KEY.P_AutoDiscard,
        }
}</span>

// query dynamodb with sort key prefixes to get all dynamic sort keys
func (db *DDB) GetAllSKs(pk string) ([]string, error) <span class="cov0" title="0">{

        sortKeys := getAllStaticSKs()

        dynamicSKPrefixes := []string{
                SORT_KEY.Notifications(""),
                SORT_KEY.Space(""),
                SORT_KEY.TabsInSpace(""),
                SORT_KEY.GroupsInSpace(""),
                SORT_KEY.SnoozedTabs(""),
                SORT_KEY.Notes(""),
        }

        for _, prefix := range dynamicSKPrefixes </span><span class="cov0" title="0">{

                keyEx :=
                        expression.Key(PK_NAME).Equal(expression.Value(pk))

                keyEx.And(expression.Key(SK_NAME).BeginsWith(prefix))

                expr, err := expression.NewBuilder().WithKeyCondition(keyEx).Build()

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error building key expression for sort_key: %v", prefix)
                }</span>

                <span class="cov0" title="0">input := &amp;dynamodb.QueryInput{
                        TableName:                 &amp;db.TableName,
                        ExpressionAttributeNames:  expr.Names(),
                        ExpressionAttributeValues: expr.Values(),
                        KeyConditionExpression:    expr.Condition(),
                }

                paginator := dynamodb.NewQueryPaginator(db.Client, input)

                for paginator.HasMorePages() </span><span class="cov0" title="0">{
                        page, err := paginator.NextPage(context.TODO())

                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error querying for dynamic sort keys. err: %v", err)
                        }</span>

                        <span class="cov0" title="0">for _, item := range page.Items </span><span class="cov0" title="0">{

                                var sk struct {
                                        SK string
                                }

                                err := attributevalue.UnmarshalMap(item, &amp;sk)

                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error un_marshalling item for sort_key: %v", prefix)
                                }</span>

                                <span class="cov0" title="0">sortKeys = append(sortKeys, sk.SK)</span>
                        }
                }
        }

        <span class="cov0" title="0">return []string{}, nil</span>
}

func (db *DDB) BatchWriter(ctx context.Context, wg *sync.WaitGroup, errChan chan error, reqs []types.WriteRequest) <span class="cov0" title="0">{

        for start := 0; start &lt; len(reqs); start += DDB_MAX_BATCH_SIZE </span><span class="cov0" title="0">{
                end := start + DDB_MAX_BATCH_SIZE
                if end &gt; len(reqs) </span><span class="cov0" title="0">{
                        end = len(reqs)
                }</span>

                // Prepare batch requests
                <span class="cov0" title="0">batchReqs := reqs[start:end]

                wReqs := map[string][]types.WriteRequest{}

                wReqs[db.TableName] = batchReqs

                wg.Add(1)

                go func(r map[string][]types.WriteRequest) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // Wait for rate limiter
                        if err := db.Limiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                                errChan &lt;- fmt.Errorf("rate limiter error: %w", err)
                                return
                        }</span>

                        // retry logic with backoff
                        <span class="cov0" title="0">var lastErr error

                        for attempt := 0; attempt &lt; 5; attempt++ </span><span class="cov0" title="0">{
                                if attempt &gt; 0 </span><span class="cov0" title="0">{
                                        // Exponential backoff with jitter
                                        backoffDuration := time.Duration(math.Pow(2, float64(attempt))) * 100 * time.Millisecond
                                        jitter := time.Duration(rand.Float64() * float64(backoffDuration/2))
                                        time.Sleep(backoffDuration + jitter)
                                }</span>

                                <span class="cov0" title="0">output, err := db.Client.BatchWriteItem(ctx, &amp;dynamodb.BatchWriteItemInput{
                                        RequestItems: r,
                                })

                                if err != nil </span><span class="cov0" title="0">{
                                        lastErr = err
                                        logger.Errorf("attempt %d failed: %v", attempt+1, err)
                                        continue</span>
                                }

                                // Handle unprocessed items
                                <span class="cov0" title="0">if len(output.UnprocessedItems) &gt; 0 </span><span class="cov0" title="0">{
                                        r = output.UnprocessedItems
                                        lastErr = fmt.Errorf("unprocessed items remain")
                                        continue</span>
                                }

                                // Success
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">if lastErr != nil </span><span class="cov0" title="0">{
                                errChan &lt;- fmt.Errorf("batch write failed after retries: %w", lastErr)
                        }</span>
                }(wReqs)

        }

}

//! not used currently
// func (db DDB) BatchReader(ctx context.Context, wg *sync.WaitGroup, errChan chan error, keys []map[string]types.AttributeValue, res chan []map[string]types.AttributeValue) {
//         for start := 0; start &lt; len(keys); start += DDB_MAX_BATCH_SIZE {
//                 end := start + DDB_MAX_BATCH_SIZE
//                 if end &gt; len(keys) {
//                         end = len(keys)
//                 }

//                 // Prepare batch requests
//                 batchReqs := keys[start:end]

//                 rReqs := map[string]types.KeysAndAttributes{}

//                 rReqs[db.TableName] = types.KeysAndAttributes{

//                         Keys: batchReqs,
//                 }

//                 wg.Add(1)

//                 go func(r map[string]types.KeysAndAttributes) {
//                         defer wg.Done()

//                         // Wait for rate limiter
//                         if err := db.Limiter.Wait(ctx); err != nil {
//                                 errChan &lt;- fmt.Errorf("rate limiter error: %w", err)
//                                 return
//                         }

//                         // retry logic with backoff
//                         var lastErr error

//                         for attempt := 0; attempt &lt; 5; attempt++ {
//                                 if attempt &gt; 0 {
//                                         // Exponential backoff with jitter
//                                         backoffDuration := time.Duration(math.Pow(2, float64(attempt))) * 100 * time.Millisecond
//                                         jitter := time.Duration(rand.Float64() * float64(backoffDuration/2))
//                                         time.Sleep(backoffDuration + jitter)
//                                 }

//                                 response, err := db.Client.BatchGetItem(ctx, &amp;dynamodb.BatchGetItemInput{
//                                         RequestItems: r,
//                                 })

//                                 if err != nil {
//                                         lastErr = err
//                                         logger.Errorf("attempt %d failed: %v", attempt+1, err)
//                                         continue
//                                 }

//                                 // Handle unprocessed items
//                                 if len(response.UnprocessedKeys) &gt; 0 {
//                                         r = response.UnprocessedKeys
//                                         lastErr = fmt.Errorf("unprocessed items remain")
//                                         continue
//                                 }

//                                 // Success
//                                 res &lt;- response.Responses[db.TableName]
//                                 return
//                         }

//                         if lastErr != nil {
//                                 errChan &lt;- fmt.Errorf("batch write failed after retries: %w", lastErr)
//                         }
//                 }(rReqs)
//         }

// }
</pre>
		
		<pre class="file" id="file35" style="display: none">package events

import (
        "encoding/json"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/sqs/types"
)

type EventType string

// Events
const (
        EventTypeSendOTP        EventType = "send_otp"
        EventTypeUserRegistered EventType = "user_registered"

        EventTypeScheduleNoteRemainder EventType = "schedule_note_remainder"
        EventTypeScheduleSnoozedTab    EventType = "schedule_snoozed_tab"
        EventTypeTriggerNoteRemainder  EventType = "trigger_note_remainder"
        EventTypeTriggerSnoozedTab     EventType = "trigger_snoozed_tab"
)

type SubEvent string

const (
        SubEventCreate SubEvent = "create"
        SubEventUpdate SubEvent = "update"
        SubEventDelete SubEvent = "delete"
)

type IEvent interface {
        GetEventType() EventType
        ToMsgAttributes() map[string]types.MessageAttributeValue
        ToJSON() string
        FromJSON(jsonStr string) error
}

type Event[T any] struct {
        EventType EventType `json:"event_type"`
        Payload   *T        `json:"payload"`
}

func New[e any](eventType EventType, payload *e) IEvent <span class="cov8" title="1">{
        return &amp;Event[e]{
                EventType: eventType,
                Payload:   payload,
        }
}</span>

func NewFromJSON[T any](jsonStr string) (*Event[T], error) <span class="cov8" title="1">{
        var ev Event[T]

        err := json.Unmarshal([]byte(jsonStr), &amp;ev)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;ev, nil</span>
}

// event_type info as map for sqs message
func (e Event[any]) ToMsgAttributes() map[string]types.MessageAttributeValue <span class="cov8" title="1">{

        return map[string]types.MessageAttributeValue{
                "event_type": {
                        DataType:    aws.String("String"),
                        StringValue: aws.String(string(e.GetEventType())),
                },
        }
}</span>

func (e Event[any]) ToJSON() string <span class="cov8" title="1">{
        jsonBytes, err := json.Marshal(e)

        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return string(jsonBytes)</span>
}

func (e *Event[T]) FromJSON(jsonStr string) error <span class="cov0" title="0">{

        return json.Unmarshal([]byte(jsonStr), &amp;e)

}</span>

func (e Event[any]) GetEventType() EventType <span class="cov8" title="1">{
        return e.EventType
}</span>

//* Event Payloads

type SendOTPPayload struct {
        Email string `json:"email"`
        OTP   string `json:"otp"`
}

type UserRegisteredPayload struct {
        Email        string `json:"email"`
        Name         string `json:"name"`
        TrailEndDate string `json:"trailEndDate"`
}

type ScheduleNoteRemainderPayload struct {
        UserId    string   `json:"userId"`
        NoteId    string   `json:"noteId"`
        TriggerAt int64    `json:"triggerAt,omitempty"`
        SubEvent  SubEvent `json:"subEvent,omitempty"`
}

type ScheduleSnoozedTabPayload struct {
        UserId       string   `json:"userId"`
        SnoozedTabId string   `json:"snoozedTabId"`
        SpaceId      string   `json:"spaceId"`
        TriggerAt    int64    `json:"triggerAt,omitempty"`
        SubEvent     SubEvent `json:"subEvent,omitempty"`
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package events

import (
        "context"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/sqs"
        "github.com/manishMandal02/tabsflow-backend/config"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

type SQSClientInterface interface {
        SendMessage(ctx context.Context, params *sqs.SendMessageInput, optFns ...func(*sqs.Options)) (*sqs.SendMessageOutput, error)
        DeleteMessage(ctx context.Context, params *sqs.DeleteMessageInput, optFns ...func(*sqs.Options)) (*sqs.DeleteMessageOutput, error)
}

type Queue struct {
        Client SQSClientInterface
        URL    string
}

func NewEmailQueue() *Queue <span class="cov0" title="0">{
        client := sqs.NewFromConfig(config.AWS_CONFIG)

        return &amp;Queue{
                Client: client,
                URL:    config.EMAIL_QUEUE_URL,
        }
}</span>

func NewNotificationQueue() *Queue <span class="cov0" title="0">{
        client := sqs.NewFromConfig(config.AWS_CONFIG)

        return &amp;Queue{
                Client: client,
                URL:    config.NOTIFICATIONS_QUEUE_URL,
        }

}</span>

// sqs helper fn to send messages
func (q Queue) AddMessage(ev IEvent) error <span class="cov8" title="1">{

        res, err := q.Client.SendMessage(context.TODO(), &amp;sqs.SendMessageInput{
                DelaySeconds:      *aws.Int32(1),
                QueueUrl:          &amp;q.URL,
                MessageBody:       aws.String(ev.ToJSON()),
                MessageAttributes: ev.ToMsgAttributes(),
        })

        if err != nil || res.MessageId == nil </span><span class="cov8" title="1">{
                logger.Errorf("Error sending message to SQS queue for event_type: %v. \n [Error]: %v", ev.GetEventType(), err)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (q Queue) DeleteMessage(r string) error <span class="cov0" title="0">{

        _, err := q.Client.DeleteMessage(context.TODO(), &amp;sqs.DeleteMessageInput{
                QueueUrl:      &amp;q.URL,
                ReceiptHandle: aws.String(r),
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error deleting message from SQS queue for receipt_handle: %v. \n [Error]: %v", r, err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package events

import (
        "context"
        "fmt"

        eb_scheduler "github.com/aws/aws-sdk-go-v2/service/scheduler"
        "github.com/aws/aws-sdk-go-v2/service/scheduler/types"
        "github.com/manishMandal02/tabsflow-backend/config"
)

type scheduler struct {
        client *eb_scheduler.Client
}

func NewScheduler() *scheduler <span class="cov0" title="0">{
        return &amp;scheduler{
                client: eb_scheduler.NewFromConfig(config.AWS_CONFIG),
        }
}</span>

// creates a schedule
//
// name - name of the schedule
//
// dateTime - date &amp; time to trigger the target. ex: at(yyyy-mm-ddThh:mm:ss)
func (s scheduler) CreateSchedule(id, dateTime string, event *string) error <span class="cov0" title="0">{

        scheduleExpression := fmt.Sprintf("at(%s)", dateTime)

        _, err := s.client.CreateSchedule(context.TODO(), &amp;eb_scheduler.CreateScheduleInput{
                Name:               &amp;id,
                ScheduleExpression: &amp;scheduleExpression,
                FlexibleTimeWindow: &amp;types.FlexibleTimeWindow{
                        Mode: types.FlexibleTimeWindowModeOff,
                },

                Target: &amp;types.Target{
                        Arn:     &amp;config.NOTIFICATIONS_QUEUE_ARN,
                        RoleArn: &amp;config.SCHEDULER_ROLE_ARN,
                        Input:   event,
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// creates a schedule
//
// name - name of the schedule
//
// dateTime - date &amp; time to trigger the target. ex: at(yyyy-mm-ddThh:mm:ss)
func (s scheduler) UpdateSchedule(name, dateTime string) error <span class="cov0" title="0">{

        scheduleExpression := fmt.Sprintf("at(%s)", dateTime)

        _, err := s.client.UpdateSchedule(context.TODO(), &amp;eb_scheduler.UpdateScheduleInput{
                Name:               &amp;name,
                ScheduleExpression: &amp;scheduleExpression,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s scheduler) DeleteSchedule(name string) error <span class="cov0" title="0">{
        _, err := s.client.DeleteSchedule(context.TODO(), &amp;eb_scheduler.DeleteScheduleInput{
                Name: &amp;name,
        })

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package http_api

import (
        "context"
        "encoding/json"
        "net/http"

        "github.com/aws/aws-lambda-go/events"
        "github.com/awslabs/aws-lambda-go-api-proxy/httpadapter"
)

type sqsHandler func(context.Context, events.SQSEvent) (interface{}, error)

// API Gateway proxy events handler
type APIGatewayHandler struct {
        baseURL    string
        handler    http.Handler
        sqsHandler sqsHandler
}

func NewAPIGatewayHandler(baseURL string, handler http.Handler) *APIGatewayHandler <span class="cov0" title="0">{
        return &amp;APIGatewayHandler{
                baseURL: baseURL,
                handler: handler,
        }
}</span>

func NewAPIGatewayHandlerWithSQSHandler(baseURL string, handler http.Handler, sH sqsHandler) *APIGatewayHandler <span class="cov0" title="0">{
        return &amp;APIGatewayHandler{
                baseURL:    baseURL,
                handler:    handler,
                sqsHandler: sH,
        }
}</span>

// wrapper handler that injects the userId
func (h *APIGatewayHandler) withUserID(userId string, handler http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                r.Header.Set("UserId", userId)
                handler.ServeHTTP(w, r)
        }</span>)
}

// processes the Lambda api event
func (h *APIGatewayHandler) Handle(ctx context.Context, event json.RawMessage) (interface{}, error) <span class="cov0" title="0">{
        // Parse API GW event
        var apiEvent events.APIGatewayProxyRequest
        err := json.Unmarshal(event, &amp;apiEvent)
        if err != nil || apiEvent.RequestContext.APIID == "" </span><span class="cov0" title="0">{
                // not a valid API Gateway event
                // check if it is an SQS event
                if h.sqsHandler != nil </span><span class="cov0" title="0">{
                        // Try to parse the event as an SQS event
                        var sqsEvent events.SQSEvent
                        if err := json.Unmarshal(event, &amp;sqsEvent); err == nil &amp;&amp; len(sqsEvent.Records) &gt; 0 </span><span class="cov0" title="0">{
                                // This is an SQS event
                                return h.sqsHandler(ctx, sqsEvent)
                        }</span>
                }
                <span class="cov0" title="0">return nil, err</span>
        }

        // Create mux for this request
        <span class="cov0" title="0">mux := http.NewServeMux()

        // Extract userId from authorizer context
        if userId, ok := apiEvent.RequestContext.Authorizer["UserId"].(string); ok </span><span class="cov0" title="0">{
                // Wrap the handler with userId injection
                mux.Handle(h.baseURL, h.withUserID(userId, h.handler))
        }</span> else<span class="cov0" title="0"> {
                // Use original handler without userId injection
                mux.Handle(h.baseURL, h.handler)
        }</span>

        // serve the request
        <span class="cov0" title="0">adapter := httpadapter.New(mux)
        return adapter.Proxy(apiEvent)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package http_api

import "net/http"

type Client interface {
        Do(req *http.Request) (*http.Response, error)
}

// HTTPClient wrapper to ensure *http.Client implements Client interface
type HTTPClient struct {
        *http.Client
}

// Do implements Client interface
func (c *HTTPClient) Do(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        return c.Client.Do(req)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package http_api

import (
        "encoding/json"
        "net/http"
)

const (
        ErrorInvalidRequest   = "Invalid request"
        ErrorRouteNotFound    = "Route not found"
        ErrorMethodNotAllowed = "Method not allowed"
        ErrorEmptyLambdaEvent = "Empty lambda event"
        ErrorMarshalling      = "Error marshaling"
        ErrorUnMarshalling    = "Error un_marshaling "
)

type ErrorBody struct {
        ErrorMsg *string `json:"error,omitempty"`
}

type APIResponse struct {
        Success bool        `json:"success"`
        Message string      `json:"message,omitempty"`
        Data    interface{} `json:"data,omitempty"`
}

func SuccessResData(w http.ResponseWriter, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        err := json.NewEncoder(w).Encode(APIResponse{Success: true, Data: data})

        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrorMarshalling, http.StatusInternalServerError)
                return
        }</span>
}

func SuccessResMsg(w http.ResponseWriter, msg string) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        err := json.NewEncoder(w).Encode(APIResponse{Success: true, Message: msg})
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrorMarshalling, http.StatusInternalServerError)
                return
        }</span>
}

func SuccessResMsgWithBody(w http.ResponseWriter, msg string, data interface{}) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        err := json.NewEncoder(w).Encode(APIResponse{Success: true, Message: msg, Data: data})
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, ErrorMarshalling, http.StatusInternalServerError)
                return
        }</span>
}

type responseWriterWritten struct {
        http.ResponseWriter
        Written bool
}

func (w *responseWriterWritten) WriteHeader(status int) <span class="cov0" title="0">{
        w.Written = true
        w.ResponseWriter.WriteHeader(status)
}</span>

func (w *responseWriterWritten) Write(b []byte) (int, error) <span class="cov0" title="0">{
        w.Written = true
        return w.ResponseWriter.Write(b)
}</span>

func (w *responseWriterWritten) HasWritten() bool <span class="cov0" title="0">{
        return w.Written

}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package http_api

import (
        "net/http"
        "strings"

        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

type Handler func(w http.ResponseWriter, r *http.Request)

type Route struct {
        Method       string
        PathSegments []string
        Handlers     []Handler
}

type Router struct {
        base       string
        routes     []*Route
        middleware []Handler
}

type IRouter interface {
        ServeHTTP(w http.ResponseWriter, req *http.Request)
        Use(handlers Handler)
        GET(path string, handlers ...Handler)
        POST(path string, handlers ...Handler)
        PATCH(path string, handlers ...Handler)
        DELETE(path string, handlers ...Handler)
}

func (r *Route) Match(method, path string) (bool, map[string]string) <span class="cov8" title="1">{
        if r.Method != method </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        // split path
        <span class="cov8" title="1">segments := strings.Split(strings.Trim(path, "/"), "/")

        if len(segments) != len(r.PathSegments) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">params := make(map[string]string)

        for i, s := range r.PathSegments </span><span class="cov8" title="1">{
                if strings.HasPrefix(s, ":") </span><span class="cov0" title="0">{
                        params[s[1:]] = segments[i]
                }</span> else<span class="cov8" title="1"> if s != segments[i] </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        <span class="cov8" title="1">return true, params</span>
}

func NewRouter(base string) IRouter <span class="cov8" title="1">{
        return &amp;Router{
                base:       base,
                routes:     []*Route{},
                middleware: []Handler{},
        }
}</span>

func (r *Router) AddRoute(method, path string, handlers []Handler) <span class="cov8" title="1">{

        segments := strings.Split(strings.Trim(path, "/"), "/")
        r.routes = append(r.routes, &amp;Route{
                Method:       method,
                PathSegments: segments,
                Handlers:     handlers,
        })
}</span>

func (r *Router) Use(middleware Handler) <span class="cov0" title="0">{
        r.middleware = append(r.middleware, middleware)
}</span>

func (r *Router) GET(path string, handlers ...Handler) <span class="cov8" title="1">{
        r.AddRoute(http.MethodGet, path, handlers)
}</span>

func (r *Router) POST(path string, handlers ...Handler) <span class="cov8" title="1">{
        r.AddRoute(http.MethodPost, path, handlers)

}</span>

func (r *Router) PATCH(path string, handlers ...Handler) <span class="cov8" title="1">{
        r.AddRoute(http.MethodPatch, path, handlers)
}</span>

func (r *Router) DELETE(path string, handlers ...Handler) <span class="cov8" title="1">{
        r.AddRoute(http.MethodDelete, path, handlers)
}</span>

func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        logger.Info("Router req: [Method]: %v \n[Path]: %v", req.Method, req.URL.Path)
        for _, route := range r.routes </span><span class="cov8" title="1">{

                match, params := route.Match(req.Method, strings.TrimPrefix(req.URL.Path, r.base))
                if match </span><span class="cov8" title="1">{

                        // wrap the original ResponseWriter
                        rw := &amp;responseWriterWritten{ResponseWriter: w}

                        logger.Info("params: %v", params)

                        // set path values
                        for key, value := range params </span><span class="cov0" title="0">{
                                req.SetPathValue(key, value)
                        }</span>
                        // run middleware
                        <span class="cov8" title="1">if len(r.middleware) &gt; 0 </span><span class="cov0" title="0">{
                                for _, m := range r.middleware </span><span class="cov0" title="0">{
                                        m(rw, req)
                                        if rw.HasWritten() </span><span class="cov0" title="0">{
                                                // stop the req, if header was written by a middleware
                                                return
                                        }</span>
                                }
                        }

                        // run handlers
                        <span class="cov8" title="1">if len(route.Handlers) == 1 </span><span class="cov8" title="1">{
                                route.Handlers[0](w, req)
                        }</span> else<span class="cov0" title="0"> {
                                for _, h := range route.Handlers </span><span class="cov0" title="0">{
                                        h(rw, req)
                                }</span>
                        }
                        <span class="cov8" title="1">return</span>
                }

        }

        <span class="cov0" title="0">http.Error(w, ErrorRouteNotFound, http.StatusNotFound)</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package logger

import "fmt"

func Error(msg string, err error) <span class="cov8" title="1">{
        fmt.Printf("❌ Logger: %v\n [Error]: %v\n", msg, err)
}</span>

func Errorf(format string, args ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, args...)

        fmt.Println("❌ Logger:Error: ", msg)
}</span>

func Dev(format string, args ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, args...)

        fmt.Println("🛜  Logger:Dev:", msg)
}</span>

func Info(format string, args ...interface{}) <span class="cov8" title="1">{
        msg := fmt.Sprintf(format, args...)

        fmt.Println("ℹ️  Logger:Info:", msg)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package test_utils

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/stretchr/testify/suite"
)

// ResponseAssertions handles common HTTP response validations
type ResponseAssertions struct {
        suite.Suite
}

// AssertResponse is a generic response checker that returns decoded response
func (a *ResponseAssertions) AssertResponse(resp *http.Response, expectedStatus int, target interface{}) error <span class="cov0" title="0">{
        a.T().Helper()

        // Check status code
        a.Equal(expectedStatus, resp.StatusCode, "HTTP status code mismatch")

        // If no target to decode into, just return
        if target == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Decode response
        <span class="cov0" title="0">if err := json.NewDecoder(resp.Body).Decode(target); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode response: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AssertCookie checks for cookie presence and attributes
func (a *ResponseAssertions) AssertCookie(resp *http.Response, name string, options ...CookieOption) *http.Cookie <span class="cov0" title="0">{
        a.T().Helper()

        for _, cookie := range resp.Cookies() </span><span class="cov0" title="0">{
                if cookie.Name == name </span><span class="cov0" title="0">{
                        // Apply all cookie validation options
                        for _, opt := range options </span><span class="cov0" title="0">{
                                opt(a, cookie)
                        }</span>
                        <span class="cov0" title="0">return cookie</span>
                }
        }
        <span class="cov0" title="0">a.Fail("Cookie not found: " + name)
        return nil</span>
}

// CookieOption defines cookie validation options
type CookieOption func(*ResponseAssertions, *http.Cookie)

// Common cookie validation options
var (
        WithSecure = func(a *ResponseAssertions, c *http.Cookie) <span class="cov0" title="0">{
                a.True(c.Secure, "Cookie should be secure")
        }</span>

        WithHTTPOnly = func(a *ResponseAssertions, c *http.Cookie) <span class="cov0" title="0">{
                a.True(c.HttpOnly, "Cookie should be HTTP only")
        }</span>

        WithPath = func(path string) CookieOption <span class="cov0" title="0">{
                return func(a *ResponseAssertions, c *http.Cookie) </span><span class="cov0" title="0">{
                        a.Equal(path, c.Path, "Cookie path mismatch")
                }</span>
        }

        WithDomain = func(domain string) CookieOption <span class="cov0" title="0">{
                return func(a *ResponseAssertions, c *http.Cookie) </span><span class="cov0" title="0">{
                        a.Equal(domain, c.Domain, "Cookie domain mismatch")
                }</span>
        }
)

// HeaderAssertions checks response headers
func (a *ResponseAssertions) AssertHeader(resp *http.Response, key, value string) <span class="cov0" title="0">{
        a.T().Helper()

        actual := resp.Header.Get(key)
        a.Equal(value, actual, key)
}</span>

// AssertContentType is a common header assertion
func (a *ResponseAssertions) AssertContentType(resp *http.Response, expected string) <span class="cov0" title="0">{
        a.T().Helper()

        a.AssertHeader(resp, "Content-Type", expected)
}</span>

// MessageAssertions for queue/pub-sub message validation
type MessageAssertions struct {
        suite.Suite
}

// AssertMessageContent is a generic message content validator
func (m *MessageAssertions) AssertMessageContent(message []byte, target interface{}) error <span class="cov0" title="0">{
        if err := json.Unmarshal(message, target); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode message: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package test_utils

import (
        "context"
        "time"

        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/manishMandal02/tabsflow-backend/pkg/db"
        "github.com/stretchr/testify/mock"
        "golang.org/x/time/rate"
)

func NewDDBMock() *db.DDB <span class="cov8" title="1">{
        return &amp;db.DDB{
                Client:    new(DynamoDBClientMock),
                TableName: "MainTable_test",
                Limiter:   rate.NewLimiter(rate.Every(20*time.Millisecond), 10),
        }
}</span>

type DynamoDBClientMock struct {
        mock.Mock
}

func (m *DynamoDBClientMock) GetItem(ctx context.Context, input *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error) <span class="cov8" title="1">{
        args := m.Called(ctx, input, optFns)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*dynamodb.GetItemOutput), args.Error(1)</span>
}

func (m *DynamoDBClientMock) PutItem(ctx context.Context, input *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error) <span class="cov8" title="1">{
        args := m.Called(ctx, input, optFns)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*dynamodb.PutItemOutput), args.Error(1)</span>
}

func (m *DynamoDBClientMock) UpdateItem(ctx context.Context, input *dynamodb.UpdateItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.UpdateItemOutput, error) <span class="cov0" title="0">{
        args := m.Called(ctx, input, optFns)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*dynamodb.UpdateItemOutput), args.Error(1)</span>
}
func (m *DynamoDBClientMock) DeleteItem(ctx context.Context, input *dynamodb.DeleteItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.DeleteItemOutput, error) <span class="cov0" title="0">{
        args := m.Called(ctx, input, optFns)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*dynamodb.DeleteItemOutput), args.Error(1)</span>
}
func (m *DynamoDBClientMock) Query(ctx context.Context, input *dynamodb.QueryInput, optFns ...func(*dynamodb.Options)) (*dynamodb.QueryOutput, error) <span class="cov0" title="0">{
        args := m.Called(ctx, input, optFns)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*dynamodb.QueryOutput), args.Error(1)</span>
}
func (m *DynamoDBClientMock) BatchGetItem(ctx context.Context, input *dynamodb.BatchGetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.BatchGetItemOutput, error) <span class="cov0" title="0">{
        args := m.Called(ctx, input, optFns)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*dynamodb.BatchGetItemOutput), args.Error(1)</span>
}

func (m *DynamoDBClientMock) BatchWriteItem(ctx context.Context, input *dynamodb.BatchWriteItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.BatchWriteItemOutput, error) <span class="cov0" title="0">{
        args := m.Called(ctx, input, optFns)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*dynamodb.BatchWriteItemOutput), args.Error(1)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package test_utils

import (
        "bytes"
        "encoding/json"
        "net/http"
        "net/http/cookiejar"
        "time"
)

// NewHTTPClient creates a configured HTTP client with cookie support
func NewHTTPClient() (*http.Client, error) <span class="cov0" title="0">{
        jar, err := cookiejar.New(nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;http.Client{
                Jar:     jar,
                Timeout: time.Second * 30,
        }, nil</span>
}

// DoRequest is a helper for making HTTP requests
func (s *E2ETestSuite) DoRequest(method, path string, body interface{}) (*http.Response, error) <span class="cov0" title="0">{
        var bodyReader *bytes.Buffer

        if body != nil </span><span class="cov0" title="0">{
                jsonBody, err := json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">bodyReader = bytes.NewBuffer(jsonBody)</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequest(method, s.Config.BaseURL+path, bodyReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if body != nil </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", "application/json")
        }</span>

        <span class="cov0" title="0">return s.HTTPClient.Do(req)</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package test_utils

import (
        "context"
        "encoding/json"
        "net/http"
        "time"

        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/sqs"
        "github.com/manishMandal02/tabsflow-backend/pkg/events"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
        "github.com/stretchr/testify/suite"
)

// TestConfig holds environment-specific configuration
type TestConfig struct {
        BaseURL      string
        DDBTableName string
        SQSQueueURL  string
        TestEmail    string
}

// E2ETestSuite base suite with common utilities
type E2ETestSuite struct {
        suite.Suite
        Config     TestConfig
        HTTPClient *http.Client
        DDBClient  *dynamodb.Client
        SQSClient  *sqs.Client
}

// WaitForSQSMessage waits for and verifies an SQS message
func (s *E2ETestSuite) WaitForSQSMessage(ctx context.Context, expectedEmail string) (*events.SendOTPPayload, error) <span class="cov0" title="0">{
        s.T().Helper()

        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{ // retry 3 times
                output, err := s.SQSClient.ReceiveMessage(ctx, &amp;sqs.ReceiveMessageInput{
                        QueueUrl:            &amp;s.Config.SQSQueueURL,
                        MaxNumberOfMessages: 1,
                        WaitTimeSeconds:     5,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">for _, msg := range output.Messages </span><span class="cov0" title="0">{
                        var payload events.SendOTPPayload
                        if err := json.Unmarshal([]byte(*msg.Body), &amp;payload); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if payload.Email == expectedEmail </span><span class="cov0" title="0">{
                                // Delete the message
                                _, _ = s.SQSClient.DeleteMessage(ctx, &amp;sqs.DeleteMessageInput{
                                        QueueUrl:      &amp;s.Config.SQSQueueURL,
                                        ReceiptHandle: msg.ReceiptHandle,
                                })
                                return &amp;payload, nil
                        }</span>
                }

                <span class="cov0" title="0">time.Sleep(time.Second * 2)</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

// AssertSuccessResponse checks if the API response indicates success
func (s *E2ETestSuite) AssertSuccessResponse(resp *http.Response) interface{} <span class="cov0" title="0">{
        s.T().Helper()

        var apiResp http_api.APIResponse
        err := json.NewDecoder(resp.Body).Decode(&amp;apiResp)
        s.Require().NoError(err)
        s.Require().True(apiResp.Success)
        return apiResp.Data
}</span>

// AssertErrorResponse checks if the API response indicates an error
func (s *E2ETestSuite) AssertErrorResponse(resp *http.Response, expectedStatus int) string <span class="cov0" title="0">{
        s.T().Helper()

        s.Require().Equal(expectedStatus, resp.StatusCode)
        var apiResp http_api.APIResponse
        err := json.NewDecoder(resp.Body).Decode(&amp;apiResp)
        s.Require().NoError(err)
        s.Require().False(apiResp.Success)
        return apiResp.Message
}</span>

// AssertHasCookie checks if a specific cookie is present
func (s *E2ETestSuite) AssertHasCookie(resp *http.Response, name string) *http.Cookie <span class="cov0" title="0">{
        s.T().Helper()

        for _, cookie := range resp.Cookies() </span><span class="cov0" title="0">{
                if cookie.Name == name </span><span class="cov0" title="0">{
                        s.True(cookie.Secure)
                        s.True(cookie.HttpOnly)
                        return cookie
                }</span>
        }
        <span class="cov0" title="0">s.Fail("Cookie not found: " + name)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package test_utils

import (
        "context"

        "github.com/aws/aws-sdk-go-v2/service/sqs"
        "github.com/manishMandal02/tabsflow-backend/pkg/events"
        "github.com/stretchr/testify/mock"
)

func NewQueueMock() *events.Queue <span class="cov8" title="1">{
        return &amp;events.Queue{
                Client: new(SQSClientMock),
                URL:    "https://email-queue-url.com",
        }
}</span>

type SQSClientMock struct {
        mock.Mock
}

func (m *SQSClientMock) SendMessage(ctx context.Context, params *sqs.SendMessageInput, optFns ...func(*sqs.Options)) (*sqs.SendMessageOutput, error) <span class="cov8" title="1">{
        args := m.Called(params)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*sqs.SendMessageOutput), args.Error(1)</span>
}
func (m *SQSClientMock) DeleteMessage(ctx context.Context, params *sqs.DeleteMessageInput, optFns ...func(*sqs.Options)) (*sqs.DeleteMessageOutput, error) <span class="cov0" title="0">{
        args := m.Called(params)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*sqs.DeleteMessageOutput), args.Error(1)</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package utils

import (
        "bytes"
        "crypto/rand"
        "fmt"
        "io"
        "math"
        "math/big"
        "net/http"

        "github.com/google/uuid"
        "github.com/manishMandal02/tabsflow-backend/pkg/http_api"
        "github.com/manishMandal02/tabsflow-backend/pkg/logger"
)

// Generates UUID v7, fallback to UUID v4 if errored while generating V7
func GenerateID() string <span class="cov0" title="0">{
        id, err := uuid.NewV7()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error generating UUID v7", err)
                return uuid.NewString()
        }</span>

        <span class="cov0" title="0">return id.String()</span>
}

func GenerateRandomString(length int) string <span class="cov0" title="0">{
        b := make([]byte, length)
        _, err := rand.Read(b)

        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%x", b)[:length]</span>
}

func GenerateOTP() string <span class="cov0" title="0">{
        maxDigits := 6
        bi, err := rand.Int(
                rand.Reader,
                big.NewInt(int64(math.Pow(10, float64(maxDigits)))),
        )
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("%0*d", maxDigits, bi)</span>
}

func MakeHTTPRequest(method, url string, headers map[string]string, body []byte, client http_api.Client) (*http.Response, string, error) <span class="cov8" title="1">{

        var req *http.Request
        var err error

        if body != nil </span><span class="cov8" title="1">{
                req, err = http.NewRequest(method, url, bytes.NewBuffer(body))

        }</span> else<span class="cov0" title="0"> {
                req, err = http.NewRequest(method, url, nil)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov8" title="1">for key, value := range headers </span><span class="cov8" title="1">{
                req.Header.Set(key, value)
        }</span>

        <span class="cov8" title="1">resp, err := client.Do(req)

        if err != nil </span><span class="cov8" title="1">{
                return nil, "", err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return resp, "", err
        }</span>

        <span class="cov8" title="1">return resp, string(respBody), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
